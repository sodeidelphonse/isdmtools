
#' @title Create block cross-validation folds for multi-source spatial datasets
#'
#' @description
#' A constructor function for the `DataFolds` S3 class. It binds multiple `sf` datasets
#' into a single object and generates spatially/environmentally-separated cross-validation folds using
#' the `blockCV` package.
#'
#' @param datasets A named list of `sf` objects. Each list element should be a
#'   spatial dataset with its name corresponding to the list element's name.
#' @param region_polygon An `sf` object representing the study area polygon.
#' @param k An integer specifying the number of folds (k-fold cross-validation).
#' @param seed An integer for reproducibility.
#' @param cv_method A character string specifying the spatial cross-validation method to use. Options are `"cluster"` (default) or `"spatial"`.
#' @param ... Additional arguments to be passed to the underlying blocking function (see \link[blockCV]{cv_cluster} or \link[blockCV]{cv_spatial}).
#'
#' @details
#' This function first binds all datasets into a single `sf` object. It then
#' applies the chosen `blockCV` method to create spatial folds. The fold IDs are
#' added to the combined data object, and the original datasets and other
#' relevant information are stored in the returned `DataFolds` object.
#'
#' @return An S3 object of class `DataFolds` containing the combined data,
#' fold information, and the original datasets.
#' @export
#'
#' @examples
#' \dontrun{
#' # Create some dummy sf data with different columns
#' library(sf)
#' set.seed(42)
#' presence_data <- data.frame(
#'   x = runif(100, 0, 4),
#'   y = runif(100, 6, 13),
#'   site = rbinom(100, 1, 0.6)
#' ) %>% st_as_sf(coords = c("x", "y"), crs = 4326)
#'
#' count_data <- data.frame(
#'   x = runif(50, 0, 4),
#'   y = runif(50, 6, 13),
#'   count = rpois(50, 5)
#' ) %>% st_as_sf(coords = c("x", "y"), crs = 4326)
#'
#' # Create a list of datasets
#' datasets_list <- list(Presence = presence_data, Count = count_data)
#'
#' # Create a dummy polygon for the region
#' ben_utm_coords <- matrix(c(0, 6, 4, 6, 4, 13, 0, 13, 0, 6), ncol = 2, byrow = TRUE)
#' ben_utm <- st_sfc(st_polygon(list(ben_utm_coords)), crs = 4326)
#' ben_utm <- st_sf(data.frame(name = "Benin"), ben_utm)
#'
#' # Create a DataFolds object using the default 'cluster' method
#' my_folds <- create_folds(datasets_list, ben_utm, k = 5)
#' print(my_folds)
#' }
#'
#' @references
#' Roberts DR, Bahn V, Ciuti S, Boyce MS, Elith J, Guillera-Arroita G, Hauenstein S, Lahoz-Monfort JJ, Schröder B, Thuiller W, et al. Cross-validation strategies for data with temporal, spatial, hierarchical, or phylogenetic structure. _Ecography_ (2017) 40:913–929. \doi{10.1111/ecog.02881}
#'
#' Valavi R, Elith J, Lahoz-Monfort JJ, Guillera-Arroita G. blockCV: an R package for generating spatially or environmentally separated folds for k-fold cross-validation of species distribution models. _bioRxiv_ (2018)357798. \doi{10.1101/357798}
#'
#' @seealso \code{\link{extract_fold.DataFolds}}, \code{\link{plot.DataFolds}}, \code{\link{print.DataFolds}}
#'
create_folds <- function(datasets, region_polygon = NULL, k = 5, seed = 23, cv_method = "cluster", ...) {

  xy_all <- bind_datasets(datasets)
  set.seed(seed)
  folds_cv <- switch(cv_method,
                     "cluster" = blockCV::cv_cluster(x = xy_all, k = k, biomod2 = FALSE, ...),
                     "spatial" = blockCV::cv_spatial(x = xy_all, k = k, biomod2 = FALSE, ...),
                     stop("Invalid `cv_method`. Must be 'cluster' or 'spatial'.")
  )

  xy_all$folds_ids <- folds_cv$folds_ids

  object <- list(
    data_all = xy_all,
    original_datasets = datasets,
    folds_info = folds_cv,
    dataset_names = names(datasets),
    k = k,
    region_polygon = region_polygon
  )
  class(object) <- "DataFolds"
  return(object)
}


#' @title Extract a specific fold from a DataFolds object
#'
#' @description
#' This method splits the data into training and testing sets for a given fold.
#' It uses the original datasets to ensure each returned `sf` object contains only
#' its original columns, avoiding `NA` values from the binding process.
#'
#' @param object A `DataFolds` S3 object.
#' @param fold An integer specifying the fold ID to be extracted as the test set.
#'
#' @return A list containing two named elements: `train` and `test`. Each of these elements is a named list of `sf` objects, with names corresponding to the original datasets.
#' @method extract_fold DataFolds
#' @export
#'
#' @examples
#' \dontrun{
#' # Assuming `my_folds` is a DataFolds object created from the `create_folds` example
#' splits_fold_3 <- extract_fold(my_folds, fold = 3)
#'
#' # Access the clean datasets for modeling
#' train_data_presence <- splits_fold_3$train$Presence
#' test_data_count <- splits_fold_3$test$Count
#'
#' # Check the columns to see that they are correct
#' names(train_data_presence)
#' names(test_data_count)
#' }
#'
#' @seealso \code{\link{create_folds}}, \code{\link{plot.DataFolds}}, \code{\link{print.DataFolds}}
#'
extract_fold.DataFolds <- function(object, fold) {
  if (!(fold %in% 1:object$k)) {
    stop(paste("Invalid fold number. Must be between 1 and", object$k))
  }

  train_folds_splits <- object$data_all %>% dplyr::filter(folds_ids != fold)
  test_folds_splits <- object$data_all %>% dplyr::filter(folds_ids == fold)

  train_splits_list <- split(train_folds_splits, train_folds_splits$datasetName)
  test_splits_list  <- split(test_folds_splits, test_folds_splits$datasetName)

  train_data <- purrr::map2(object$original_datasets, train_splits_list, sf::st_filter)
  test_data <- purrr::map2(object$original_datasets, test_splits_list, sf::st_filter)

  return(list(
    train = train_data,
    test = test_data
  ))
}

# --- Generic function for S3 dispatch ---

#' @exportS3Method extract_fold generic
extract_fold <- function(object, ...) {
  UseMethod("extract_fold")
}

# --- Default method for unexpected types ---

#' @exportS3Method extract_fold default
extract_fold.default <- function(x) {
  cat("Default method for class", sQuote(class(x)), ".\n")
}


#' @title Print a summary of a DataFolds object
#'
#' @description
#' A method to print a concise summary of the `DataFolds` object, including the
#' number of folds, the datasets included, and a breakdown of individuals per
#' dataset across all folds.
#'
#' @param x A `DataFolds` S3 object.
#' @param ... Additional arguments (not used by this method).
#'
#' @return The object invisibly.
#' @method print DataFolds
#' @export
#'
print.DataFolds <- function(x, ...) {
  cat("A DataFolds S3 object with", x$k, "folds.\n")
  cat("Datasets included:", paste(x$dataset_names, collapse = ", "), "\n\n")
  cat("Summary of individuals per dataset:\n")

  summary_df <- x$data_all %>%
    dplyr::group_by(datasetName, folds_ids) %>%
    dplyr::summarise(n = n(), .groups = "keep") %>%
    dplyr::ungroup()

  print(summary_df)
  invisible(x)
}


#' @title Plot block cross-validation folds for multiple datasets
#'
#' @description
#' A method to visualize the spatial blocks and the corresponding train/test
#' partitions for each fold of a `DataFolds` object.
#'
#' @param x A `DataFolds` S3 object.
#' @param ... Additional arguments (not used by this method).
#'
#' @return A `ggplot2` object that can be printed or saved.
#' @method plot DataFolds
#' @export
#'
#' @examples
#' \dontrun{
#' # Create some dummy sf data
#' library(sf)
#' set.seed(42)
#' presence_data <- data.frame(
#'   x = runif(100, 0, 4),
#'   y = runif(100, 6, 13),
#'   site = rbinom(100, 1, 0.6)
#' ) %>%
#'   st_as_sf(coords = c("x", "y"), crs = 4326)
#'
#' count_data <- data.frame(
#'   x = runif(50, 0, 4),
#'   y = runif(50, 6, 13),
#'   count = rpois(50, 5)
#' ) %>%
#'   st_as_sf(coords = c("x", "y"), crs = 4326)
#'
#' # Create a list of datasets
#' datasets_list <- list(Presence = presence_data, Count = count_data)
#'
#' # Create a dummy polygon for the region (e.g., Benin)
#' ben_utm_coords <- matrix(c(0, 6, 4, 6, 4, 13, 0, 13, 0, 6), ncol = 2, byrow = TRUE)
#' ben_utm <- st_sfc(st_polygon(list(ben_utm_coords)), crs = 4326)
#' ben_utm <- st_sf(data.frame(name = "Benin"), ben_utm)
#'
#' # Create a DataFolds object for the example
#' my_folds <- create_folds(datasets_list, ben_utm, k = 5)
#'
#' # Now you can plot the object
#' plot_cv <- plot(my_folds)
#' print(plot_cv)
#' }
#'
#' @seealso \code{\link{extract_fold.DataFolds}}, \code{\link{print.DataFolds}}
#'
plot.DataFolds <- function(x, ...) {

  num_datasets <- length(x$dataset_names)
  shapes <- c(16, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15)[1:num_datasets]
  names(shapes) <- x$dataset_names

  plot_data_list <- purrr::map(1:x$k, function(fold_id) {
    x$data_all %>%
      dplyr::mutate(
        Set = ifelse(folds_ids == fold_id, "Test", "Train"),
        fold_panel = factor(fold_id)
      )
  })

  folds_xy_expanded <- dplyr::bind_rows(plot_data_list)

  plot_cv <- ggplot2::ggplot(folds_xy_expanded) +
    ggspatial::geom_sf(data = x$region_polygon, fill = NA, color = "grey20") +
    ggspatial::geom_sf(ggplot2::aes(color = Set, shape = datasetName), size = 1.2) +
    ggplot2::scale_color_manual(name = "Partition", values = c("Train" = "blue", "Test" = "orange")) +
    ggplot2::scale_shape_manual(name = "Dataset", values = shapes) +
    ggplot2::facet_wrap(~ fold_panel, labeller = ggplot2::labeller(fold_panel = function(x) paste("Fold", x)), nrow = 1) +
    ggplot2::theme_bw(base_size = 12) +
    ggplot2::theme(
      legend.position = "right",
      strip.text = ggplot2::element_text(size = 13),
      panel.grid.major = ggplot2::element_line(color = "grey80"),
      panel.grid.minor = ggplot2::element_line(color = "grey90")
    ) +
    ggplot2::labs(title = paste("Spatial Cross-Validation Folds"), x = "Longitude", y = "Latitude") +
    ggspatial::annotation_north_arrow(location = "tl", height = grid::unit(0.6, "cm"), width = grid::unit(0.3, "cm")) +
    ggspatial::annotation_scale(location = "br", bar_cols = c("grey60", "white"))

  return(plot_cv)
}


#-- Helper function to bind sf objects into a single object ----

#' @title Bind a list of spatial datasets for spatial blocking.
#' @description Helper function to create a single `sf` object with a `datasetName` column
#' useful for spatial blocking in cross-validation.
#'
#' @param datasets A named list of `sf` datasets having the same geographical projection and
#' coordinates reference system (CRS)
#'
#' @return An `sf` object containing all datasets along with their corresponding name.
#' @noRd
#'
bind_datasets <- function(datasets) {
  if (!is.list(datasets) || is.null(names(datasets))) {
    stop("Input must be a named list of data.frame objects.", call. = FALSE)
  }
  datasets_labeled <- purrr::map2(datasets, names(datasets), ~ .x %>% dplyr::mutate(datasetName = .y))
  bound_data <- dplyr::bind_rows(datasets_labeled)
  bound_data$datasetName <- factor(bound_data$datasetName, levels = names(datasets))

  return(bound_data)
}

# --- Citation information ---

#' @title A Toolkit for Integrated Species Distribution Models
#'
#' @description
#' The `isdmtools` package provides a set of tools for preparing, evaluating and visualizing spatial data for integrated species distribution models (ISDMs).
#'
#' @author SODE Akoeugnigan Idelphonse
#' @name isdmtools-package
#' @aliases isdmtools
#' @keywords internal
"_PACKAGE"
