[{"path":"https://sodeidelphonse.github.io/isdmtools/articles/isdm-evaluation-workflow.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"ISDM Evaluation Workflow","text":"demonstrated Get started guide, first output isdmtools package set clean sf objects, makes easy integrate various spatial modeling tools using block cross-validation techniques. extracted training testing data can directly fed preferred integrated modeling tools inlabru, PointedSDMs, GLMs/GAMs tools can accommodate multisource spatial data. ensures model predictions validated using robust spatial cross-validation approach comprehensive evaluation metrics. vignette shows isdmtools can used predictive modelling tools inlabru complete workflow integrated species distribution modelling (ISDM) analysis.","code":""},{"path":"https://sodeidelphonse.github.io/isdmtools/articles/isdm-evaluation-workflow.html","id":"step-1-fitting-a-bayesian-integrated-model-with-the-inlabru","dir":"Articles","previous_headings":"Introduction","what":"Step 1: Fitting a Bayesian integrated model with the inlabru","title":"ISDM Evaluation Workflow","text":"inlabru package wrapper R-INLA package designed Bayesian Latent Gaussian Modelling using INLA (Integrated Laplace Nested Approximations) Extensions. Let‚Äôs develop Bayesian spatial model simulated data presented Get started guide. Model definition assume following basic joint model shared latent signal Œæ(.)\\xi(.) (.e.¬†Gaussian random field): IPP\\mathrm{IPP} means Inhomogeneous Poisson Process ùê¨\\mathbf{s} vector location coordinates. can now prepare remaining data required fit integrated model. First, need define mesh used approximate latent field well integration points IPP likelihood. step, set prior distributions latent parameters range marginal standard deviation. define observation model data type fuse using joint likelihood estimation INLA. Model implementation can collect model results fitting process. expected, estimated spatial range higher 1. strong spatial autocorrelation simulated data.","code":"\\begin{matrix}   Y_{\\mathrm{count},i}|\\xi(.) \\sim \\mathrm{Pois} \\left(\\mu_i \\right), \\quad i = 1,\\ldots,n,\\\\  \\log(\\mu_i) = \\beta_{0,\\mathrm{count}} + \\xi(\\mathbf{s}_i)\\\\[3mm]  X_{\\mathrm{presence}}|\\xi(.) \\sim \\mathrm{IPP} \\left(\\lambda(\\mathbf{s}) \\right),\\\\ \\log (\\lambda(\\mathbf{s})) = \\beta_{0,\\mathrm{presence}} + \\xi(\\mathbf{s})\\\\ \\end{matrix} # Create a \"mesh\" for the latent field  mesh <- fmesher::fm_mesh_2d(      boundary = ben_sf,      max.edge = c(0.2, 0.5),      offset = c(1e-3, 0.6),      cutoff = 0.10,      crs = \"epsg:4326\" ) ggplot() + inlabru::gg(mesh) # Set the PC-prior for the SPDE model. We estimate a longer range value as no spatial  # autocorrelation was defined in the data generation process: pcmatern <- INLA::inla.spde2.pcmatern(mesh,                                       prior.range = c(1, 0.1), # P(spatial range < 1) = 0.1                                       prior.sigma = c(1, 0.1)  # P(sigma > 1) = 0.1                                       )     # The shared spatial latent component is denoted by 'spde' jcmp <- ~ -1 + Presence_intercept(1) + Count_intercept(1) +                   spde(geometry, model = pcmatern)     # Count observation model obs_model_count <- inlabru::bru_obs(      formula = count ~  + Count_intercept + spde,      family = \"poisson\",      data = train_data$Count  )     # Presence-only observation model (LGCP) obs_model_pres <- inlabru::bru_obs(      formula = geometry ~ Presence_intercept + spde,      family = \"cp\",      data = train_data$Presence,      domain = list(geometry = mesh),      samplers = list(geometry = ben_sf) )     # Model fit jfit <- inlabru::bru(jcmp, obs_model_count, obs_model_pres,                         options = list(control.inla = list(int.strategy = \"eb\"),                                        bru_max_iter = 20)                     ) jfit$summary.fixed  #>                     mean        sd      0.025quant  0.5quant   0.975quant  mode      kld  #> Count_intercept    -0.2497590 0.3086958 -0.8547916 -0.2497590  0.3552737  -0.2497590  0  #> Presence_intercept  0.9269141 0.2836352  0.3709992  0.9269141  1.4828289   0.9269141  0  #>    jfit$summary.hyperpar  #>                mean        sd      0.025quant  0.5quant   0.975quant  mode  #> Range for spde 3.535334 2.5240208  0.9513318   2.8572241  10.2509603  1.9527898  #> Stdev for spde 0.512346 0.1926203  0.2183487   0.4842595  0.9647017   0.4317979"},{"path":"https://sodeidelphonse.github.io/isdmtools/articles/isdm-evaluation-workflow.html","id":"step-2-model-prediction","dir":"Articles","previous_headings":"Introduction","what":"Step 2: Model prediction","title":"ISDM Evaluation Workflow","text":"","code":"# Define the prediction grids and projection system grids      <- fmesher::fm_pixels(mesh, mask = ben_sf) projection <- \"+proj=longlat +ellps=WGS84 +datum=WGS84\" # Model predictions jpred <- predict(jfit,                   newdata = grids,                   formula = ~ spde + Presence_intercept,                  n.samples = 500,                   seed = 24) jpred <- prepare_predictions(jpred)   jpred_count <- predict(jfit,                         newdata = grids,                         formula = ~ spde + Count_intercept ,                        n.samples = 500, seed = 24) jpred_count <- prepare_predictions(jpred_count)"},{"path":"https://sodeidelphonse.github.io/isdmtools/articles/isdm-evaluation-workflow.html","id":"step-3-habitat-suitability-analysis","dir":"Articles","previous_headings":"Introduction","what":"Step 3: Habitat suitability analysis","title":"ISDM Evaluation Workflow","text":"obtained model predictions, can use isdmtools perform habitat suitability analysis. allow us proceed evaluation models visualisation results.","code":"# Probability of presence jt_prob <- suitability_index(jpred,                              post_stat = c(\"q0.025\", \"mean\", \"q0.975\"),                              output_format = \"prob\",                             response_type = \"joint.po\",                             projection = projection,                             scale_independent = TRUE                             ) plot(jt_prob) # Expected counts jt_count <- suitability_index(jpred_count,                                post_stat = c(\"q0.025\", \"mean\", \"q0.975\"),                                output_format = \"response\",                               response_type = \"count\",                               projection = projection                               ) plot(jt_count)"},{"path":"https://sodeidelphonse.github.io/isdmtools/articles/isdm-evaluation-workflow.html","id":"step-4-model-performance-evaluation-using-the-test-data","dir":"Articles","previous_headings":"Introduction","what":"Step 4: Model performance evaluation using the test data","title":"ISDM Evaluation Workflow","text":"Various performance metrics can now computed, including dataset-specific weighted composite scores. One can obtain detailed overview evaluation results via summary() method. noticed, continuous-outcome metrics MAE (mean absolute error) RMSE (root mean squared error) available presence-data, makes sense. Furthermore, weighted composite scores continuous responses identical individual counterparts, since one count response. Moreover, can check get_background() documentation details background sample generated model evaluation. Next, can iterate five spatial folds obtain average model performance, calculate variation metrics blocks. Finally, run model full ‚Äòdatasets_list‚Äô make final prediction.","code":"xy_observed <- rbind(st_coordinates(datasets_list$Presence)[, c(\"X\",\"Y\")],                st_coordinates(datasets_list$Count)[datasets_list$Count$count > 0, c(\"X\",\"Y\")])      metrics <- c(\"auc\", \"tss\", \"accuracy\", \"rmse\", \"mae\")  eval_metrics <- compute_metrics(test_data,                                  prob_raster = jt_prob$mean,                                  expected_response = jt_count$mean,                                 xy_excluded = xy_observed,                                  metrics = metrics,                                 overall_roc_metrics = c(\"auc\", \"tss\", \"accuracy\"),                                 response_counts = \"count\"                                 ) print(eval_metrics)  #> ISDM Model Evaluation Results #> ---------------------------------------------- #> Datasets Evaluated: Presence, Count   #> Overall Performance: #>  TOT ROC SCORE     : 0.8048 #>  TOT ERROR SCORE   : 1.9353 #> ---------------------------------------------- summary(eval_metrics)  #> ============================================== #>        ISDM EVALUATION SUMMARY REPORT #> ============================================== #> Generated on: 2026-01-19 04:41:02   #> --- Model Evaluation Settings --- #> Random Seed         : 25 #> Background Points   : 1000 #> Spatial Context     : BackgroundPoints object attached #> Threshold Logic     : best #> Optimality Criterion: youden #> Prediction Type     : Absolute Count (No Offset)  #> --- Detailed Metric Table --- #>         Presence Count #> AUC         0.917 0.750 #> TSS         0.791 0.750 #> ACCURACY    0.794 0.778 #> RMSE          N/A 2.119 #> MAE           N/A 1.752  #> --- Composite Scores (Weighted) --- #>     AUC      TSS ACCURACY     RMSE      MAE  #>    0.852    0.775    0.788    2.119    1.752   #> --- Overall Performance --- #>  TOT ROC SCORE     : 0.8048 #>  TOT ERROR SCORE   : 1.9353 #> =============================================="},{"path":"https://sodeidelphonse.github.io/isdmtools/articles/isdm-evaluation-workflow.html","id":"step-5-prediction-mapping","dir":"Articles","previous_headings":"Introduction","what":"Step 5: Prediction mapping","title":"ISDM Evaluation Workflow","text":"can now generate formal prediction map ready publication.","code":"map <- generate_maps(jt_prob,                     var_names = c(\"q0.025\", \"mean\", \"q0.975\"),                     base_map = ben_sf,                    legend_title = \"suitability\",                      panel_labels = c(\"(a) q2.5%\", \"(b) Mean\", \"(c) q97.5%\"),                    xaxis_breaks = seq(0, 4, 1),                    yaxis_breaks = seq(6, 13, 2)                    ) map"},{"path":"https://sodeidelphonse.github.io/isdmtools/articles/isdm-evaluation-workflow.html","id":"conclusion","dir":"Articles","previous_headings":"","what":"Conclusion","title":"ISDM Evaluation Workflow","text":"successfully fused multi-source biodiversity data generated spatially independent partitions robust model validation using isdmtools. toolkit enabled resampling data, thereby reducing spatial autocorrelation effects modelling process. facilitated analysis comprehensive evaluation ISDM using well-known metrics fields statistics machine learning.","code":""},{"path":"https://sodeidelphonse.github.io/isdmtools/articles/isdmtools.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Get started","text":"vignette bridge gap ‚Äúspatial data‚Äù ‚Äúready modelling.‚Äù fundamental philosophy isdmtools provide standardised bridge diverse biodiversity spatial data sources robust spatial cross-validation (CV) strategy evaluating integrated species distribution models (ISDMs). tutorial assist preparing data generating spatial folds ‚Äî essential first steps fitting Integrated Species Distribution Model (ISDM).","code":""},{"path":[]},{"path":"https://sodeidelphonse.github.io/isdmtools/articles/isdmtools.html","id":"step-1-simulate-some-spatial-data","dir":"Articles","previous_headings":"Data Preparation","what":"Step 1: Simulate some spatial data","title":"Get started","text":"Let‚Äôs consider simple scenario generating two spatial datasets representing presence abundance given species defined study area.","code":"# Simulate a list of presence-only and count data set.seed(42) presence_data <- data.frame(   x = runif(100, 0, 4),    y = runif(100, 6, 13),    site = rbinom(100, 1, 0.6) ) %>% st_as_sf(coords = c(\"x\", \"y\"), crs = 4326)  count_data <- data.frame(   x = runif(50, 0, 4),    y = runif(50, 6, 13),    count = rpois(50, 5) ) %>% st_as_sf(coords = c(\"x\", \"y\"), crs = 4326)  datasets_list <- list(Presence = presence_data, Count = count_data)  # Define the study region (e.g. Benin's boundary rectangle) ben_coords <- matrix(c(0, 6, 4, 6, 4, 13, 0, 13, 0, 6), ncol = 2, byrow = TRUE) ben_sf <- st_sf(data.frame(name = \"Region\"),                            st_sfc(st_polygon(list(ben_coords)),                            crs = 4326))                            # Gnerate some continuous covariates set.seed(42) r   <- rast(ben_sf, nrow = 100, ncol = 100) r[] <- rnorm(ncell(r))  rtmp   <- r rtmp[] <- runif(ncell(r), 5, 10)  r <- c(r, rtmp + r) names(r) <- c(\"cov1\", \"cov2\")"},{"path":"https://sodeidelphonse.github.io/isdmtools/articles/isdmtools.html","id":"step-2-spatial-partitioning","dir":"Articles","previous_headings":"Data Preparation","what":"Step 2: Spatial Partitioning","title":"Get started","text":"Partitioning spatial data spatial folds important since helps reduce spatial autocorrelation observations estimate realistic model performance.","code":"# Create the DataFolds object using the default method folds <- create_folds(datasets_list, ben_sf, k = 5) #>   train test #> 1   120   30 #> 2   110   40 #> 3   125   25 #> 4   125   25 #> 5   120   30 #>  train test #> 1   120   30 #> 2   110   40 #> 3   125   25 #> 4   125   25 #> 5   120   30 # Visualize the folds with custom styling plot(folds, nrow = 1) +   scale_x_continuous(breaks = seq(0, 4, 1)) +   scale_y_continuous(breaks = seq(6, 13, 2)) +   theme_minimal() +   labs(title = \"Spatial Block Partitioning\") # Create the DataFolds object using the `spatialsample` blocking engine fold_ss <- create_folds(datasets_list, ben_sf, cv_method = \"block\")  # Using the native autoplot of `spatialesample` ggplot2::autoplot(fold_ss) # Folds summary summary(fold_ss) #> DataFolds Object Summary #> ------------------------ #> Total observations: 150  #> Number of folds (k): 5  #> Datasets merged: Presence, Count  #>  #> Global Observations per Fold and Dataset: #>       #>       Presence Count Sum #>   1         22     8  30 #>   2         18    14  32 #>   3         19     8  27 #>   4         16    15  31 #>   5         25     5  30 #>   Sum      100    50 150 #>  #> Spatial Context: Study area polygon is defined (available for plotting).  #> DataFolds Object Summary #> ------------------------ #> Total observations: 150  #> Number of folds (k): 5  #> Datasets merged: Presence, Count  #> #> Global Observations per Fold and Dataset: #>     #>     Presence Count Sum #>  1         22     8  30 #>  2         18    14  32 #>  3         19     8  27 #>  4         16    15  31 #>  5         25     5  30 #> Sum      100    50 150 #> #> Spatial Context: Study area polygon is defined (available for plotting)."},{"path":"https://sodeidelphonse.github.io/isdmtools/articles/isdmtools.html","id":"step-3-folds-diagnostics","dir":"Articles","previous_headings":"Data Preparation","what":"Step 3: Folds diagnostics","title":"Get started","text":"Various diagnostic analyses can performed folds created previous step. Specifically, prior information spatial range exploratory analysis, value can used rho argument check_folds function. can used compare estimated internal size inter-block gap. procedure applied post-modelling analysis check posterior range estimated aligns spatial geometry specified folds blocks.","code":"# Check spatial independence of folds geo_diag <- check_folds(folds, plot = TRUE) print(geo_diag) #>  #> === isdmtools: Spatial Fold Diagnostic === #>  #> Internal Size (Max Distance to Fold Centroid): #>    Min. 1st Qu.  Median    Mean 3rd Qu.    Max.  #>   140.6   141.7   148.5   169.0   185.9   228.1  #>  #> Inter-block Gap (Min Distance to Nearest Fold): #>    Min. 1st Qu.  Median    Mean 3rd Qu.    Max.  #>   32.71   32.71   42.08   41.62   45.42   55.16  #> ==========================================  # Plot results plot(geo_diag) #> === isdmtools: Spatial Fold Diagnostic === #> #> Internal Size (Max Distance to Fold Centroid): #>  Min. 1st Qu.  Median    Mean 3rd Qu.    Max.  #>  140.6   141.7   148.5   169.0   185.9   228.1  #> #> Inter-block Gap (Min Distance to Nearest Fold): #>   Min. 1st Qu.  Median    Mean 3rd Qu.    Max.  #>  32.71   32.71   42.08   41.62   45.42   55.16  #> ============================================= # Check environmental balance of folds set.seed(42)  # for background sample reproducibility env_diag <- check_env_balance(folds,                               covariates = r,                               n_background = 5000                               ) print(env_diag) #>  #> === isdmtools: Environmental Balance Diagnostic === #> Significance (p > 0.05 = Balanced) #> Overlap (D > 0.6 = Representative) #>  #>  Variable       Type  p_val Schoener_D #>      cov1 Continuous 0.3053      0.902 #>      cov2 Continuous 0.1631      0.893 #> ==================================================  #> === isdmtools: Environmental Balance Diagnostic === #> Significance (p > 0.05 = Balanced) #> Overlap (D > 0.6 = Representative) #> #> Variable       Type  p_val Schoener_D #>     cov1 Continuous 0.3053      0.902 #>     cov2 Continuous 0.1631      0.893 #> =================================================== # Plot outputs plot(env_diag) # Combined diagnostics summarise_fold_diagnostics(geo_diag, env_diag) #>  #> ========================================== #>    isdmtools: INTEGRATED FOLD SUMMARY      #> ========================================== #>  #>         Domain                     Metric   Value    Status #>     Geographic Avg Internal Distance (km) 168.970 Separated #>     Geographic    Avg Inter-Fold Gap (km)  41.617 Separated #>  Environmental         Median Overlap (D)   0.897  Balanced #>  Environmental            Minimum p-value   0.163  Balanced #>  #> ------------------------------------------ #> CONCLUSION: Folds are spatially independent  #> and environmentally representative. #> ==========================================  #> ========================================== #>   isdmtools: INTEGRATED FOLD SUMMARY      #> ========================================== #> #>        Domain                     Metric   Value    Status #>    Geographic Avg Internal Distance (km) 168.970 Separated #>    Geographic    Avg Inter-Fold Gap (km)  41.617 Separated #> Environmental         Median Overlap (D)   0.897  Balanced #> Environmental            Minimum p-value   0.163  Balanced #> #> ------------------------------------------ #> CONCLUSION: Folds are spatially independent  #> and environmentally representative. #> =========================================="},{"path":"https://sodeidelphonse.github.io/isdmtools/articles/isdmtools.html","id":"step-4-data-extraction-for-modelling","dir":"Articles","previous_headings":"Data Preparation","what":"Step 4: Data Extraction for Modelling","title":"Get started","text":"spatial folds created, one can extract data see looks like right goes modelling tool like inlabru. can access ‚Äòtrain‚Äô ‚Äòtest‚Äô sets corresponding datasets follows:","code":"# Extract fold 1 splits_1 <- extract_fold(folds, fold = 1)  # Accessing the training and testing sets for the \"Presence\" source head(splits_1$train$Presence) #> Simple feature collection with 6 features and 1 field #> Geometry type: POINT #> Dimension:     XY #> Bounding box:  xmin: 1.144558 ymin: 7.515971 xmax: 3.748302 ymax: 12.73826 #> Geodetic CRS:  WGS 84 #>   site                  geometry #> 1    0 POINT (3.659224 10.38372) #> 2    1 POINT (3.748302 7.520104) #> 3    0 POINT (1.144558 7.515971) #> 4    1 POINT (3.321791 8.722615) #> 5    1 POINT (2.566982 12.59719) #> 6    1 POINT (2.076384 12.73826) head(splits_1$test$Presence) #> Simple feature collection with 6 features and 1 field #> Geometry type: POINT #> Dimension:     XY #> Bounding box:  xmin: 0.4699494 ymin: 8.489662 xmax: 1.899988 ymax: 10.28493 #> Geodetic CRS:  WGS 84 #>   site                   geometry #> 1    1  POINT (1.830967 10.26256) #> 2    1  POINT (1.021715 9.169121) #> 3    1   POINT (1.849171 9.75053) #> 4    1 POINT (0.4699494 8.489662) #> 5    1  POINT (1.899988 10.28493) #> 6    1 POINT (0.5548407 8.874446)"},{"path":"https://sodeidelphonse.github.io/isdmtools/articles/isdmtools.html","id":"conclusion","dir":"Articles","previous_headings":"","what":"Conclusion","title":"Get started","text":"Congratulations! successfully fused multi-source biodiversity data generated spatially independent partitions robust model validation. using create_folds() related folds‚Äô diagnostic tools, ‚Äôve ensured model evaluation account spatial autocorrelation, providing realistic estimate predictive performance. isdmtools journey continues model fitting comprehensive evaluation. Depending needs, recommend following paths: Model Fitting: Use training data extracted via extract_fold() fit models using modelling engines like inlabru, PointedSDMs, standard GAMs tools can support spatial data multiple response formats. Integrated Evaluation: One predictions obtained, evaluate models analyse outputs. advanced guide ISDM Evaluation Workflow covers model building external tools, calculation dataset-specific composite scores, suitability analysis mapping isdmtools","code":""},{"path":"https://sodeidelphonse.github.io/isdmtools/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Akoeugnigan Idelphonse SODE. Author, maintainer. Adand√© Belarmain Fandohan. Contributor. Elias Teixeira Krainski. Contributor. Romain Gl√®l√® Kaka√Ø. Contributor.","code":""},{"path":"https://sodeidelphonse.github.io/isdmtools/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Sode . ., Fandohan . B., Krainski E. T., Assogbadjo . E., Gl√®l√® Kaka√Ø R. (2025). Integrating Presence-Abundance Data Predict Baobab (Adansonia digitata L.) Distribution: Bayesian Data Fusion Framework. Preprint. doi:10.21203/rs.3.rs-7871875/v1","code":"@Article{,   title = {Integrating Presence-only and Abundance Data to Predict Baobab (Adansonia digitata L.) Distribution: A Bayesian Data Fusion Framework},   author = {A. I. Sode and A. B. Fandohan and E. T. Krainski and A. E. Assogbadjo and R. {Gl√®l√® Kaka√Ø}},   journal = {Preprint},   year = {2025},   doi = {10.21203/rs.3.rs-7871875/v1}, }"},{"path":"https://sodeidelphonse.github.io/isdmtools/index.html","id":"isdmtools","dir":"","previous_headings":"","what":"Toolkit for Evaluating and Analysing Integrated Species Distribution Models in R","title":"Toolkit for Evaluating and Analysing Integrated Species Distribution Models in R","text":"isdmtools R package designed streamline process preparing visualizing spatial data biodiversity distribution modeling evaluating resulting models. package designed specific focus integrated species distribution models (ISDMs) based multisource geospatial datasets within Bayesian framework. includes presence-, count presence-absence data. provides set tools producing robust reproducible workflows block cross-validation, data management visualization, ISDM evaluation.","code":""},{"path":[]},{"path":"https://sodeidelphonse.github.io/isdmtools/index.html","id":"how-to-install-the-package","dir":"","previous_headings":"","what":"How to install the package?","title":"Toolkit for Evaluating and Analysing Integrated Species Distribution Models in R","text":"can install development version isdmtools directly GitHub using devtools.","code":"install.packages(\"devtools\")  devtools::install_github(\"sodeidelphonse/isdmtools\")"},{"path":"https://sodeidelphonse.github.io/isdmtools/index.html","id":"how-can-contributors-manage-the-package-dependencies","dir":"","previous_headings":"","what":"How can contributors manage the package dependencies?","title":"Toolkit for Evaluating and Analysing Integrated Species Distribution Models in R","text":"project uses renv manage package dependencies ensure reproducibility. install necessary packages project, simply follow steps: Make sure renv package installed: project directory working directory, use renv install packages listed renv.lock file:","code":"install.packages(\"renv\") renv::restore()"},{"path":"https://sodeidelphonse.github.io/isdmtools/index.html","id":"key-features","dir":"","previous_headings":"","what":"Key Features","title":"Toolkit for Evaluating and Analysing Integrated Species Distribution Models in R","text":"package provides set core functions classes handle common tasks data preparation, visualization model evaluation: Data Preparation: Create DataFolds object bind multiple sf datasets generate spatially-separated cross-validation folds using constructor function create_folds(). ensures resulting models robust spatial autocorrelation. key methods check_folds() check_env_balance() operate DataFolds efficiently check independence environmental balance created folds, respectively. S3 methods available manipulation classes generated methods. Suitability Analysis: Standardize model predictions consistent mapping compute final habitat suitability index. suitability_index() function transforms raw integrated model predictions suitability score using inverse complementary log-log transform (cloglog). Model Evaluation: Compute comprehensive evaluation metrics, including ROC-based continuous-outcome metrics dataset (\"<METRIC>_DatasetName\") using compute_metrics() constructor. package also handles dataset-weighted composite scores (\"<METRIC>_Comp\"), providing holistic view model performance. Note sample_background() constructor called internally sample pseudo-absences presence-data. However, users option extracting BackgroundPoints object get_background() helper order print visualise generated pseudo-absences. Mapping & Visualization: Visualize model predictions final habitat suitability maps. plotting method generate_maps() designed provide clear informative map visualizing multiple variables model predictions (e.g.¬†mean, median, standard deviation quantiles), providing easy way interpret models‚Äô results. Users can customize final ggplot2 object needed. S3 Methods: package includes summary(), print() plot() methods different classes provide concise summary clear visualization spatial data partitions, folds diagnostics evaluation metrics. methods discussed package vignettes.","code":""},{"path":"https://sodeidelphonse.github.io/isdmtools/index.html","id":"how-does-it-work","dir":"","previous_headings":"","what":"How does it work?","title":"Toolkit for Evaluating and Analysing Integrated Species Distribution Models in R","text":"core workflow isdmtools involves creating DataFolds object extracting specific folds modeling pipeline.","code":""},{"path":"https://sodeidelphonse.github.io/isdmtools/index.html","id":"data-preparation","dir":"","previous_headings":"","what":"Data preparation","title":"Toolkit for Evaluating and Analysing Integrated Species Distribution Models in R","text":"First, let‚Äôs load package create dummy data.","code":"library(isdmtools) library(sf) library(ggplot2) library(dplyr)  # Set the random seed for reproducibility set.seed(42)  # Presence-only data (e.g. Citizen science data) presence_data <- data.frame(   x = runif(100, 0, 4),   y = runif(100, 6, 13), ) %>%   st_as_sf(coords = c(\"x\", \"y\"), crs = 4326)  # Count data (e.g. species count from a structured design) count_data <- data.frame(   x = runif(50, 0, 4),   y = runif(50, 6, 13),   count = rpois(50, 5) ) %>%   st_as_sf(coords = c(\"x\", \"y\"), crs = 4326)  # Create a list of datasets datasets_list <- list(Presence = presence_data, Count = count_data)"},{"path":"https://sodeidelphonse.github.io/isdmtools/index.html","id":"spatial-partitioning","dir":"","previous_headings":"","what":"Spatial partitioning","title":"Toolkit for Evaluating and Analysing Integrated Species Distribution Models in R","text":"can now create spatial folds using default blocking engine. detailed introduction package, please see Get started guide.","code":"# Create the DataFolds object my_folds <- create_folds(datasets_list, k = 5, seed = 23) print(my_folds)  # Visualize the folds plot(my_folds)  # Extract a specific fold (e.g., Fold 3) for modeling and evaluation splits_fold_3 <- extract_fold(my_folds, fold = 3)  # You can access both 'train' and 'test' sets and their corresponding datasets  train_data <- splits_fold_3$train  test_data <- splits_fold_3$test"},{"path":"https://sodeidelphonse.github.io/isdmtools/index.html","id":"contributing","dir":"","previous_headings":"","what":"Contributing","title":"Toolkit for Evaluating and Analysing Integrated Species Distribution Models in R","text":"welcome contributions! encounter issue feature request, please open issue GitHub repository .","code":""},{"path":"https://sodeidelphonse.github.io/isdmtools/index.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Toolkit for Evaluating and Analysing Integrated Species Distribution Models in R","text":"cite package research work, run following command R session generate plain text BiTex entry citation:","code":"citation(\"isdmtools\")"},{"path":"https://sodeidelphonse.github.io/isdmtools/reference/BackgroundPoints-methods.html","id":null,"dir":"Reference","previous_headings":"","what":"Methods for BackgroundPoints objects ‚Äî BackgroundPoints-methods","title":"Methods for BackgroundPoints objects ‚Äî BackgroundPoints-methods","text":"plot: Visualizes background points generated BackgroundPoints object. plot shows cells NA values locations excluded sample (white color) points argument provided sample_background. background points generated colored red. print: Display points (first last ones) R session.","code":""},{"path":"https://sodeidelphonse.github.io/isdmtools/reference/BackgroundPoints-methods.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Methods for BackgroundPoints objects ‚Äî BackgroundPoints-methods","text":"","code":"# S3 method for class 'BackgroundPoints' plot(x, ...)  # S3 method for class 'BackgroundPoints' print(x, ...)"},{"path":"https://sodeidelphonse.github.io/isdmtools/reference/BackgroundPoints-methods.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Methods for BackgroundPoints objects ‚Äî BackgroundPoints-methods","text":"x BackgroundPoints S3 object. ... Additional arguments (used method).","code":""},{"path":"https://sodeidelphonse.github.io/isdmtools/reference/BackgroundPoints-methods.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Methods for BackgroundPoints objects ‚Äî BackgroundPoints-methods","text":"Invisibly returns original object.","code":""},{"path":[]},{"path":"https://sodeidelphonse.github.io/isdmtools/reference/BackgroundPoints-methods.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Methods for BackgroundPoints objects ‚Äî BackgroundPoints-methods","text":"","code":"if (FALSE) { # \\dontrun{ library(terra) set.seed(123) r  <- rast(nrows = 100, ncols = 100, xmin = 0, xmax = 10, ymin = 0, ymax = 10) terra::values(r) <- runif(ncell(r)) pts <- spatSample(r, size = 100, xy = TRUE, values = FALSE)  # Requesting few points with their x and y coordinates set.seed(235) bg_sample1 <- sample_background(r, points = pts, n = 500, xy = TRUE, cells = FALSE) plot(bg_sample1) print(bg_sample1)  # Requesting points more than available non-NA cells bg_sample2 <- sample_background(r, points = pts, n = 10000, xy =TRUE, cells = FALSE) dim(bg_sample2$bg) plot(bg_sample2) } # }"},{"path":"https://sodeidelphonse.github.io/isdmtools/reference/DataFolds-methods.html","id":null,"dir":"Reference","previous_headings":"","what":"Methods for manipulating data from DataFolds object. ‚Äî DataFolds-methods","title":"Methods for manipulating data from DataFolds object. ‚Äî DataFolds-methods","text":"extract_fold: Extract specific fold data partition. plot: method visualize spatial blocks corresponding train/test partitions observations block cross-validation (CV). autoplot: method native visualisation spatialsample objects. print: method print folds' information per dataset, including species geometry number points excluded via spatial buffering. summary: method print concise summary DataFolds object.","code":""},{"path":"https://sodeidelphonse.github.io/isdmtools/reference/DataFolds-methods.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Methods for manipulating data from DataFolds object. ‚Äî DataFolds-methods","text":"","code":"extract_fold(object, fold, ...)  # S3 method for class 'DataFolds' extract_fold(object, fold, ...)  # S3 method for class 'DataFolds' plot(x, nrow = 1, annotate = TRUE, ...)  # S3 method for class 'DataFolds' print(x, ...)  # S3 method for class 'DataFolds' summary(object, ...)  # S3 method for class 'DataFolds' autoplot(object, ...)"},{"path":"https://sodeidelphonse.github.io/isdmtools/reference/DataFolds-methods.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Methods for manipulating data from DataFolds object. ‚Äî DataFolds-methods","text":"object object spatial fold can extracted (e.g. DataFolds object) fold integer specifying fold ID extracted test set. ... Additional arguments passed specific methods. x DataFolds object. nrow integer specifying number rows needed panel plot. default 1. annotate TRUE, north arrow scale bar added plot.","code":""},{"path":"https://sodeidelphonse.github.io/isdmtools/reference/DataFolds-methods.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Methods for manipulating data from DataFolds object. ‚Äî DataFolds-methods","text":"extract_fold: list containing two named elements (train test). DataFolds class, element named list sf objects, names corresponding original datasets. plot: Returns ggplot object can modified. autoplot: Returns ggplot object. print: Invisibly returns original object. summary: Invisibly returns original object table observations count per fold dataset type.","code":""},{"path":"https://sodeidelphonse.github.io/isdmtools/reference/DataFolds-methods.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Methods for manipulating data from DataFolds object. ‚Äî DataFolds-methods","text":"extract_fold method generic, meaning provides consistent interface different types objects. method dispatched depends class object argument. primary purpose abstract process accessing training testing data given fold, making easier write generic cross-validation loops. method splits data training testing sets given fold, using original datasets ensure returned sf object contains original columns.","code":""},{"path":[]},{"path":"https://sodeidelphonse.github.io/isdmtools/reference/DataFolds-methods.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Methods for manipulating data from DataFolds object. ‚Äî DataFolds-methods","text":"","code":"if (FALSE) { # \\dontrun{ # Create a list of some dummy sf data with different columns library(sf) library(dplyr) set.seed(42)  presence_data <- data.frame(   x = runif(100, 0, 4),   y = runif(100, 6, 13),   site = rbinom(100, 1, 0.6) ) %>% st_as_sf(coords = c(\"x\", \"y\"), crs = 4326)  count_data <- data.frame(   x = runif(50, 0, 4),   y = runif(50, 6, 13),   count = rpois(50, 5) ) %>% st_as_sf(coords = c(\"x\", \"y\"), crs = 4326)  datasets_list <- list(Presence = presence_data, Count = count_data)  # Create a dummy polygon for the study region ben_coords <- matrix(c(0, 6, 4, 6, 4, 13, 0, 13, 0, 6), ncol = 2, byrow = TRUE) ben_sf <- st_sfc(st_polygon(list(ben_coords)), crs = 4326) ben_sf <- st_sf(data.frame(name = \"Benin\"), ben_sf)  # Create a DataFolds object with the default 'cluster' method my_folds <- create_folds(datasets_list, ben_sf, k = 5) print(my_folds)  #-- Extract the desired fold (e.g. third fold for k-fold CV) splits_fold_3 <- extract_fold(my_folds, fold = 3)  # Access the clean datasets for modeling train_data_presence <- splits_fold_3$train$Presence test_data_count <- splits_fold_3$test$Count  # Check the columns to see that they are correct names(train_data_presence) names(test_data_count)  #-- Plot the previous folds plot_cv <- plot(my_folds) print(plot_cv)  # You can even customize the plot (e.g. adjusting the axes breaks) plot_cv <- plot_cv +   ggplot2::scale_x_continuous(breaks = seq(0, 4, 1)) +   ggplot2::scale_y_continuous(breaks = seq(6, 13, 2)) print(plot_cv)  #-- Summarise folds information summary(my_folds)  #-- Run the native autoplot for a \\code{spatialsample} blocking method fold_ss <- create_folds(datasets_list, ben_sf, cv_method = \"block\", k = 5) autoplot(fold_ss) plot(fold_ss) } # }"},{"path":"https://sodeidelphonse.github.io/isdmtools/reference/EnvDiagnostic-methods.html","id":null,"dir":"Reference","previous_headings":"","what":"Methods for EnvDiagnostic objects ‚Äî EnvDiagnostic-methods","title":"Methods for EnvDiagnostic objects ‚Äî EnvDiagnostic-methods","text":"Methods EnvDiagnostic objects","code":""},{"path":"https://sodeidelphonse.github.io/isdmtools/reference/EnvDiagnostic-methods.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Methods for EnvDiagnostic objects ‚Äî EnvDiagnostic-methods","text":"","code":"# S3 method for class 'EnvDiagnostic' print(x, ...)  # S3 method for class 'EnvDiagnostic' plot(x, ...)"},{"path":"https://sodeidelphonse.github.io/isdmtools/reference/EnvDiagnostic-methods.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Methods for EnvDiagnostic objects ‚Äî EnvDiagnostic-methods","text":"x EnvDiagnostic object. ... Additional arguments.","code":""},{"path":"https://sodeidelphonse.github.io/isdmtools/reference/EnvDiagnostic-methods.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Methods for EnvDiagnostic objects ‚Äî EnvDiagnostic-methods","text":"print: Invisibly returns original object. plot: Returns ggplot2 object covariates' density plots.","code":""},{"path":[]},{"path":"https://sodeidelphonse.github.io/isdmtools/reference/GeoDiagnostic-methods.html","id":null,"dir":"Reference","previous_headings":"","what":"Methods for GeoDiagnostic objects ‚Äî GeoDiagnostic-methods","title":"Methods for GeoDiagnostic objects ‚Äî GeoDiagnostic-methods","text":"Methods GeoDiagnostic objects","code":""},{"path":"https://sodeidelphonse.github.io/isdmtools/reference/GeoDiagnostic-methods.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Methods for GeoDiagnostic objects ‚Äî GeoDiagnostic-methods","text":"","code":"# S3 method for class 'GeoDiagnostic' print(x, ...)  # S3 method for class 'GeoDiagnostic' plot(x, ...)"},{"path":"https://sodeidelphonse.github.io/isdmtools/reference/GeoDiagnostic-methods.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Methods for GeoDiagnostic objects ‚Äî GeoDiagnostic-methods","text":"x GeoDiagnostic object. ... Additional arguments.","code":""},{"path":"https://sodeidelphonse.github.io/isdmtools/reference/GeoDiagnostic-methods.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Methods for GeoDiagnostic objects ‚Äî GeoDiagnostic-methods","text":"print: Invisibly returns original object. plot: Returns ggplot2 object.","code":""},{"path":[]},{"path":"https://sodeidelphonse.github.io/isdmtools/reference/ISDMmetrics-methods.html","id":null,"dir":"Reference","previous_headings":"","what":"Methods for ISDMmetrics Objects ‚Äî ISDMmetrics-methods","title":"Methods for ISDMmetrics Objects ‚Äî ISDMmetrics-methods","text":"Objects class ISDMmetrics returned compute_metrics. methods provide structured ways view, summarize manipulate evaluation results. get_background helper function extract BackgroundPoints object ISDMmetrics object.","code":""},{"path":"https://sodeidelphonse.github.io/isdmtools/reference/ISDMmetrics-methods.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Methods for ISDMmetrics Objects ‚Äî ISDMmetrics-methods","text":"","code":"# S3 method for class 'ISDMmetrics' print(x, ...)  # S3 method for class 'ISDMmetrics' summary(object, ...)  # S3 method for class 'ISDMmetrics' x[...]  # S3 method for class 'ISDMmetrics' plot(x, include_composite = TRUE, ...)  # S3 method for class 'ISDMmetrics' as.data.frame(x, ...)  get_background(x)"},{"path":"https://sodeidelphonse.github.io/isdmtools/reference/ISDMmetrics-methods.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Methods for ISDMmetrics Objects ‚Äî ISDMmetrics-methods","text":"x object class ISDMmetrics. ... Additional arguments passed method. object object class ISDMmetrics. include_composite Logical. weighted composite scores included plot? Defaults TRUE.","code":""},{"path":"https://sodeidelphonse.github.io/isdmtools/reference/ISDMmetrics-methods.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Methods for ISDMmetrics Objects ‚Äî ISDMmetrics-methods","text":"print: Invisibly returns original object. summary: Invisibly returns NULL. plot: Returns ggplot2 object. [: Returns subset ISDMmetrics object. .data.frame: Returns tidy data.frame long format. BackgroundPoints object present, otherwise NULL.","code":""},{"path":[]},{"path":"https://sodeidelphonse.github.io/isdmtools/reference/ISDMmetrics-methods.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Methods for ISDMmetrics Objects ‚Äî ISDMmetrics-methods","text":"","code":"if (FALSE) { # \\dontrun{ #--- Compute metrics for an Integrated SDM # This object will contain metrics for e.g., Presence-only and Count data eval_results <- compute_metrics(   test_data = test_data,   prob_raster = suitability_raster,   expected_response = expected_raster,   n_background = 1000,   metrics = c(\"rmse\", \"mae\", \"auc\", \"tss\"),   is_pred_rate = TRUE, # model with offset   exposure = \"area\"    # standardized exposure name across the counts data )  #--- Quick view of the results print(eval_results)  #--- Generate a full replication report # summary.ISDMmetrics shows seeds, threshold logic, and prediction type summary(eval_results)  #--- Visual comparison of metrics plot(eval_results, include_composite = TRUE)  #--- Background visualization (for Presence-Only data) bg_data <- get_background(eval_results) if (!is.null(bg_data)) {   plot(bg_data) }  #--- Export to tabular format for external reports results_df <- as.data.frame(eval_results) head(results_df)  #--- Subset specific metrics for custom analysis auc_only <- eval_results[grep(\"AUC\", names(eval_results))] } # }"},{"path":"https://sodeidelphonse.github.io/isdmtools/reference/calc_niche_overlap.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate Niche Overlap (Schoener's D) ‚Äî calc_niche_overlap","title":"Calculate Niche Overlap (Schoener's D) ‚Äî calc_niche_overlap","text":"Computes overlap two distributions.","code":""},{"path":"https://sodeidelphonse.github.io/isdmtools/reference/calc_niche_overlap.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate Niche Overlap (Schoener's D) ‚Äî calc_niche_overlap","text":"","code":"calc_niche_overlap(x, y, n = 512)"},{"path":"https://sodeidelphonse.github.io/isdmtools/reference/calc_niche_overlap.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate Niche Overlap (Schoener's D) ‚Äî calc_niche_overlap","text":"x Numeric vector (e.g., predictions spatial fold values). y Numeric vector (e.g., observations background values). n Numeric. Number points density estimation. Default 512.","code":""},{"path":"https://sodeidelphonse.github.io/isdmtools/reference/calc_niche_overlap.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate Niche Overlap (Schoener's D) ‚Äî calc_niche_overlap","text":"Numeric value 0 1.","code":""},{"path":"https://sodeidelphonse.github.io/isdmtools/reference/calc_niche_overlap.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate Niche Overlap (Schoener's D) ‚Äî calc_niche_overlap","text":"","code":"if (FALSE) { # \\dontrun{ library(isdmtools)  # Create two identical distributions (should have high overlap) v1 <- rnorm(1000, mean = 10, sd = 1) v2 <- rnorm(1000, mean = 10, sd = 1) overlap_high <- calc_niche_overlap(v1, v2)  # Create two divergent distributions (should have low overlap) v3 <- rnorm(1000, mean = 20, sd = 1) overlap_low <- calc_niche_overlap(v1, v3) } # }"},{"path":"https://sodeidelphonse.github.io/isdmtools/reference/check_env_balance.html","id":null,"dir":"Reference","previous_headings":"","what":"Check Environmental Balance of Folds ‚Äî check_env_balance","title":"Check Environmental Balance of Folds ‚Äî check_env_balance","text":"Evaluates whether environmental covariates well-balanced across folds. extracts values SpatRaster point locations. large rasters, uses background sample represent study area.","code":""},{"path":"https://sodeidelphonse.github.io/isdmtools/reference/check_env_balance.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check Environmental Balance of Folds ‚Äî check_env_balance","text":"","code":"check_env_balance(object, ...)  # S3 method for class 'DataFolds' check_env_balance(   object,   covariates,   plot_type = c(\"density\", \"boxplot\"),   n_background = 10000,   ... )"},{"path":"https://sodeidelphonse.github.io/isdmtools/reference/check_env_balance.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check Environmental Balance of Folds ‚Äî check_env_balance","text":"object DataFolds object. ... Additional arguments passed sample_background. covariates SpatRaster (terra) containing environmental layers. must coordinate reference system (CRS) sf objects used blocking. plot_type Character. Either \"density\" (default) \"boxplot\". n_background Numeric. Number background points sample environmental space representation. Default 10,000.","code":""},{"path":"https://sodeidelphonse.github.io/isdmtools/reference/check_env_balance.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check Environmental Balance of Folds ‚Äî check_env_balance","text":"object class EnvDiagnostic.","code":""},{"path":"https://sodeidelphonse.github.io/isdmtools/reference/check_env_balance.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Check Environmental Balance of Folds ‚Äî check_env_balance","text":"function also calculates environmental niche overlap using Schoener's D metric (Schoener, 1968). metric ranges 0 (overlap) 1 (identical niches). Schoener's D: Quantifies well fold represents available environmental space (background). median value reported across folds covariate. Interpretation: Values > 0.6 generally indicate folds representative study area's environmental conditions. Low values suggest cross-validation results may biased model tested environmental conditions rarely encountered training.","code":""},{"path":[]},{"path":"https://sodeidelphonse.github.io/isdmtools/reference/check_env_balance.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Check Environmental Balance of Folds ‚Äî check_env_balance","text":"","code":"if (FALSE) { # \\dontrun{ library(sf) library(terra) library(ggplot2) library(isdmtools)  # Generate data as a list of sf objects set.seed(42) presence_data <- data.frame(  x = runif(100, 0, 4),  y = runif(100, 6, 13),  site = rbinom(100, 1, 0.6) ) %>% st_as_sf(coords = c(\"x\", \"y\"), crs = 4326)  count_data <- data.frame(   x = runif(50, 0, 4),  y = runif(50, 6, 13),  count = rpois(50, 5) ) %>% st_as_sf(coords = c(\"x\", \"y\"), crs = 4326)  datasets_list <- list(Presence = presence_data, Count = count_data)  ben_coords <- matrix(c(0, 6, 4, 6, 4, 13, 0, 13, 0, 6), ncol = 2, byrow = TRUE) ben_sf <- st_sfc(st_polygon(list(ben_coords)), crs = 4326) ben_sf <- st_sf(data.frame(name = \"Benin\"), ben_sf)  # a) Continuous covariates r   <- rast(ben_sf, nrow = 100, ncol = 100, crs = 'epsg:4326') r[] <- rnorm(ncell(r)) rtmp   <- r rtmp[] <- runif(ncell(r), 5, 10)  r_stk <- c(r, rtmp + r) names(r_stk) <- c(\"cov1\", \"cov2\")  # Create Folds folds <- create_folds(   datasets_list,   region_polygon = ben_sf,   cv_method = \"cluster\" )  # Check Environmental Representation env_diag <- suppressWarnings(check_env_balance(   folds,   covariates = r_stk,   n_background = 5000) )  # View p-values in console print(env_diag)  # View density plots plot(env_diag)  # b) Mixture of continuous and categorical covariates set.seed(42) r_temp <- rast(extent = c(0, 4, 6, 13), res = 0.1, val = runif(2500, 15, 25)) r_land <- rast(extent = c(0, 4, 6, 13), res = 0.1, val = sample(1:3, 2500, TRUE))  # Set up land cover as a factor levels(r_land) <- data.frame(ID = 1:3, cover = c(\"Forest\", \"Grass\", \"Urban\")) env_stack <- c(r_temp, r_land) names(env_stack) <- c(\"temperature\", \"land_use\")  # Run the diagnostic with 2000 cells over 2800 available env_diag <- check_env_balance(   folds,   covariates = env_stack,   n_background = 2000,   plot_type = \"boxplot\" )  # Inspect results # 'temperature' will show a p-value and Schoener's D # 'land_use' will show a p-value (Chi-sq) and Schoener_D as NA print(env_diag) plot(env_diag) } # }"},{"path":"https://sodeidelphonse.github.io/isdmtools/reference/check_folds.html","id":null,"dir":"Reference","previous_headings":"","what":"Check Spatial Folds Independence ‚Äî check_folds","title":"Check Spatial Folds Independence ‚Äî check_folds","text":"Evaluates geometric properties spatial folds ensure spatial independence cross-validation. function verifies block sizes inter-block gaps sufficient relative prior model's estimated spatial range (\\(\\rho\\)).","code":""},{"path":"https://sodeidelphonse.github.io/isdmtools/reference/check_folds.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check Spatial Folds Independence ‚Äî check_folds","text":"","code":"check_folds(object, ...)  # S3 method for class 'DataFolds' check_folds(object, rho = NULL, plot = TRUE, ...)"},{"path":"https://sodeidelphonse.github.io/isdmtools/reference/check_folds.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check Spatial Folds Independence ‚Äî check_folds","text":"object DataFolds object created create_folds(). ... Additional arguments. rho Numeric. Optional. spatial range (km) estimated exploratory analysis (e.g., cv_spatial_autocor) used block size one estimated integrated model (e.g., Mat√©rn range parameter). plot Logical. TRUE, returns diagnostic plot.","code":""},{"path":"https://sodeidelphonse.github.io/isdmtools/reference/check_folds.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check Spatial Folds Independence ‚Äî check_folds","text":"object class GeoDiagnostic.","code":""},{"path":"https://sodeidelphonse.github.io/isdmtools/reference/check_folds.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Check Spatial Folds Independence ‚Äî check_folds","text":"function assesses independence based minimum gap folds compared spatial range (\\(\\rho\\)): Contiguous: Gap = 0. High risk spatial leakage; observations test folds spatially correlated training data. Weakly Independent: 0 < Gap < \\(\\rho\\). physical gap exists, correlation remains 0.1. Independent: \\(\\rho \\le\\) Gap < \\(2\\rho\\). Spatial correlation 0.1 boundary; considered robust CV applications. Strongly Independent: Gap \\(\\ge 2\\rho\\). Spatial correlation effectively zero, providing rigorous test model extrapolation.","code":""},{"path":"https://sodeidelphonse.github.io/isdmtools/reference/check_folds.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Check Spatial Folds Independence ‚Äî check_folds","text":"Roberts DR, Bahn V, Ciuti S, Boyce MS, Elith J, Guillera-Arroita G, Hauenstein S, Lahoz-Monfort JJ, Schr√∂der B, Thuiller W, et al. Cross-validation strategies data temporal, spatial, hierarchical, phylogenetic structure. Ecography (2017) 40:913‚Äì929. doi:10.1111/ecog.02881","code":""},{"path":[]},{"path":"https://sodeidelphonse.github.io/isdmtools/reference/check_folds.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Check Spatial Folds Independence ‚Äî check_folds","text":"","code":"if (FALSE) { # \\dontrun{ library(sf) library(terra) library(ggplot2) library(isdmtools)  # Generate the data as a list of sf objects set.seed(42) presence_data <- data.frame(  x = runif(100, 0, 4),  y = runif(100, 6, 13),  site = rbinom(100, 1, 0.6) ) %>% st_as_sf(coords = c(\"x\", \"y\"), crs = 4326)  count_data <- data.frame(   x = runif(50, 0, 4),  y = runif(50, 6, 13),  count = rpois(50, 5) ) %>% st_as_sf(coords = c(\"x\", \"y\"), crs = 4326)  datasets_list <- list(Presence = presence_data, Count = count_data)  ben_coords <- matrix(c(0, 6, 4, 6, 4, 13, 0, 13, 0, 6), ncol = 2, byrow = TRUE) ben_sf <- st_sfc(st_polygon(list(ben_coords)), crs = 4326) ben_sf <- st_sf(data.frame(name = \"Benin\"), ben_sf)  # Create Folds using create_folds() folds <- create_folds(   datasets_list,   region_polygon = ben_sf,   k = 5,   cv_method = \"cluster\" )  # Check Spatial Independence # Assuming autocorrelation range (rho) is 150 km spat_diag <- check_folds(folds, rho = 150, plot = TRUE)  # View results print(spat_diag) plot(spat_diag) } # }"},{"path":"https://sodeidelphonse.github.io/isdmtools/reference/check_spatial_geometry.html","id":null,"dir":"Reference","previous_headings":"","what":"Diagnostic for Spatial Folds Geometry ‚Äî check_spatial_geometry","title":"Diagnostic for Spatial Folds Geometry ‚Äî check_spatial_geometry","text":"Internal function evaluate spatial structure folds blocked cross-validation.","code":""},{"path":"https://sodeidelphonse.github.io/isdmtools/reference/check_spatial_geometry.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Diagnostic for Spatial Folds Geometry ‚Äî check_spatial_geometry","text":"","code":"check_spatial_geometry(   data_all,   fold_col = \"folds_ids\",   rho = NULL,   plot = TRUE )"},{"path":"https://sodeidelphonse.github.io/isdmtools/reference/check_spatial_geometry.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Diagnostic for Spatial Folds Geometry ‚Äî check_spatial_geometry","text":"data_all sf object containing pooled locations fold IDs. fold_col Character. Name fold ID column. rho Numeric. Estimated spatial range (km). plot Logical. TRUE, generates ggplot object.","code":""},{"path":"https://sodeidelphonse.github.io/isdmtools/reference/compute_metrics.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute Evaluation Metrics for Integrated Spatial Models from Multisource Datasets ‚Äî compute_metrics","title":"Compute Evaluation Metrics for Integrated Spatial Models from Multisource Datasets ‚Äî compute_metrics","text":"function computes wide range evaluation metrics single-layer raster model predictions list one point-based datasets. designed handle different data types (presence-, presence-absence, count data) provides individual metrics well dataset-weighted composite scores.","code":""},{"path":"https://sodeidelphonse.github.io/isdmtools/reference/compute_metrics.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute Evaluation Metrics for Integrated Spatial Models from Multisource Datasets ‚Äî compute_metrics","text":"","code":"compute_metrics(   test_data,   prob_raster = NULL,   xy_excluded = NULL,   expected_response = NULL,   n_background = 1000,   response_counts = \"counts\",   response_pa = \"present\",   threshold_method = c(\"best\", \"fixed\"),   best_method = c(\"youden\", \"closest.topleft\"),   fixed_threshold = NA_real_,   best_threshold_policy = c(\"first\", \"last\", \"max.prec\", \"max.recall\", \"max.accu\",     \"max.f1\"),   metrics = NULL,   overall_roc_metrics = NULL,   overall_error_metrics = NULL,   is_pred_rate = FALSE,   exposure = NULL,   seed = 25,   ... )"},{"path":"https://sodeidelphonse.github.io/isdmtools/reference/compute_metrics.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute Evaluation Metrics for Integrated Spatial Models from Multisource Datasets ‚Äî compute_metrics","text":"test_data named list sf objects. sf object represents different test dataset must contain point geometries. function loop named dataset list. particular, test_data can 'fold' create_folds extract_fold outputs, independent validation datasets available. prob_raster SpatRaster object unique layer containing model's predictions probability scale (0-1). represents suitability index, values used compute ROC-based metrics (e.g., AUC, TSS, F1 score). argument optional continuous-outcome metrics requested count data. xy_excluded optional SpatVector sf object representing locations pseudo-absence points sampled, occupied areas known background points. relevant presence-(PO) data. Default NULL. expected_response SpatRaster object containing model's predictions continuous scale (.e. counts rate offset used; see suitability_index). values used compute continuous-outcome metrics (e.g., RMSE, MAE, MAPE). argument required continuous-outcome metric requested. n_background integer. specifies number pseudo-absence points sample presence-data. Default 1000 (see sample_background). response_counts character. column name sf objects contains observed counts. Default 'counts' must standardized across count data sets. Exceptionally, positive measurements (e.g. biomass) supported allowing exposure default value. cases, continuous-outcome metrics can requested. response_pa character. column name sf objects contains presence-absence data (1 presence, 0 absence). Default 'present' must standardized across PA data sets. threshold_method character. method used selecting threshold converting probabilities binary outcomes. Options 'best' (using best_method) 'fixed'. Default \"best\". best_method character. method used selecting best threshold threshold_method 'best'. Options 'youden' 'closest.topleft'. Default \"youden\" criterion maximizes sensitivity specificity. fixed_threshold numeric. value (0-1) used fixed threshold threshold_method 'fixed'. Default NA_real_. best_threshold_policy character. Specifies policy selecting threshold multiple thresholds yield 'best' value. Options \"first\", \"last\", \"max.prec\" (max precision), \"max.recall\" (max recall), \"max.accu\" (max accuracy), \"max.f1\" (max F1 score). Default \"first\". metrics character. vector metric names compute. NULL, \"auc\" (area ROC curve), \"tss\" (true skill statistics), \"accuracy\", \"F1\" (F1 score), \"precision\", \"recall\" computed ROC-based metrics \"rmse\" (root mean squared error), \"mae\" (mean absolute error) \"r2\" (pseudo R-squared) computed error-based metrics. overall_roc_metrics character. vector subset ROC-based metrics used overall composite score (TOT_ROC_SCORE). Allowed options \"auc\", \"tss\", \"accuracy\", \"F1\". NULL, sensible default \"auc\", \"tss\" \"accuracy\". metric useful objective obtain rapid overview rank multiple candidate models fitted datasets via blocked cross-validation using multi-criteria assessment. overall_error_metrics character. vector subset continuous outcome metrics used overall composite score (TOT_ERROR_SCORE). Allowed options \"rmse\", \"mae\", \"r2\". NULL, default \"rmse\" \"mae\". order obtain overall interpretable score, imperative select metrics scale. is_pred_rate logical. TRUE, indicates expected_response contains predictions intensity (per-unit--exposure) scale (typical Bayesian models offset inlabru). FALSE, assumes predictions original scale (e.g., counts). Default FALSE. exposure character. column name sf objects contains exposure variable (offset). relevant count (sometimes presence-absence) data must standardized across types datasets. is_pred_rate TRUE, observed counts rescaled exposure variable. Default NULL. seed integer. sets seed random number generation, used pseudo-absence sampling ensure reproducibility. Default 25. ... Additional arguments passed internal functions, particularly coords function.","code":""},{"path":"https://sodeidelphonse.github.io/isdmtools/reference/compute_metrics.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute Evaluation Metrics for Integrated Spatial Models from Multisource Datasets ‚Äî compute_metrics","text":"object class ISDMmetrics. named list containing requested metrics. names follow consistent convention: \"<METRIC>_<DATASET_NAME>\": Individual metric score dataset. \"<METRIC>_Comp\": sample-size-weighted composite score given metric across valid datasets. \"TOT_ROC_SCORE\": overall ROC-based composite score, averaged across selected overall_roc_metrics. \"TOT_ERROR_SCORE\": overall error-based composite score, averaged across overall_error_metrics. ISDMmetrics object list containing performance values individual datasets composite scores. Use .data.frame() flatten cross-validation summaries.","code":""},{"path":"https://sodeidelphonse.github.io/isdmtools/reference/compute_metrics.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Compute Evaluation Metrics for Integrated Spatial Models from Multisource Datasets ‚Äî compute_metrics","text":"function handles three main data types combination thereof: Presence-Absence (PA) Data: function uses response_pa column prob_raster calculate ROC-based metrics (see coords, details available metrics). Count Data (optionally measurements): function uses expected_response calculate continuous-outcome metrics can optionally use prob_raster calculate ROC-based metrics count data. Presence-(PO) Data: function uses presence points sf object (xy_excluded) samples n pseudo-absence points study background (excluding xy_excluded) create presence-absence dataset ROC-based metric calculations. models based count data, user wants compute continuous-outcome ROC-based metrics, expected_response raster must supplied continuous metrics prob_raster must also supplied ROC-based metrics. prob_raster can obtained converting continuous-outcome prediction (e.g., linear predictor) suitability index using suitability_index function. available continuous-outcome metrics given follows: Root Mean Squared Error (RMSE): measure average magnitude errors. square root average squared differences prediction actual observation. gives higher weight large errors. $$RMSE = \\sqrt{\\frac{1}{n}\\sum_{=1}^{n}(\\hat{y_i} - y_i)^2}$$. Mean Absolute Error (MAE): measure average magnitude errors without considering direction. average absolute differences prediction actual observation. $$MAE = \\frac{1}{n}\\sum_{=1}^{n}|\\hat{y_i} - y_i|$$. Mean Absolute Percentage Error (MAPE): measure prediction accuracy percentage. calculated average absolute percentage errors observation. can useful comparing performance across different datasets models. $$MAPE = \\frac{100\\%}{n}\\sum_{=1}^{n}|\\frac{\\hat{y_i} - y_i}{y_i}|$$. Pseudo R-squared (\\(R^2\\)): measure proportion variance observed data explained model's predictions. $$R^2 = 1 - \\frac{SS_{res}}{SS_{tot}}$$ : \\(y_i\\) observed continuous value location \\(\\). \\(\\hat{y}_i\\) predicted value model location \\(\\) (e.g., posterior mean predictions). \\(\\bar{y}\\) mean observed values. \\(SS_{res}\\) residual sum squares, measures discrepancy observed predicted values: $$SS_{res} = \\sum_{=1}^{n}(y_i - \\hat{y}_i)^2$$ \\(SS_{tot}\\) total sum squares, measures total variance observed data: $$SS_{tot} = \\sum_{=1}^{n}(y_i - \\bar{y})^2$$ weighted composite score (<METRIC>_Comp) computed requested metric taking sample-size-weighted average across datasets metric successfully calculated. total composite score (TOT_ROC_SCORE TOT_ERROR_SCORE) also computed averaging selected metrics corresponding 'overall metrics' character vector. can viewed quick multi-criterion decision metric multiple models comparison.","code":""},{"path":[]},{"path":"https://sodeidelphonse.github.io/isdmtools/reference/compute_metrics.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute Evaluation Metrics for Integrated Spatial Models from Multisource Datasets ‚Äî compute_metrics","text":"","code":"if (FALSE) { # \\dontrun{ # Assuming you have dummy prediction rasters and a list of sf objects # with 'counts' and 'present' columns for counts and PA data, respectively.  # Example 1: Compute metrics for a presence-absence model # pa_metrics <- compute_metrics( #   test_data = list(ds1 = my_pa_sf), #   prob_raster = prob_raster,  # compulsory prob_raster #   response_pa = \"present\"     # default labels column for all PA data # )  # Example 2: Compute continuous-outcome metrics for a count-based model # cont_metrics <- compute_metrics( #   test_data = list(ds1 = my_count_sf), #   expected_response = expected_raster, # prediction on count scale #   response_count = \"counts\",           # default labels column for all counts #   metrics = c(\"rmse\", \"mae\", \"mape\") # )  # Example 3: Compute both continuous and ROC-based metrics for a count model # The user must first generate a suitability index (prob_raster & expected_response) # from the linear scale prediction (pred_eta).  # expected_raster <- suitability_index(pred_eta, #                    response_type = \"count\", #                    output_format = \"response\") # suitability_raster <- suitability_index(pred_eta, #                       response_type = \"count\", #                       output_format = \"prob\") # full_metrics <- compute_metrics( #   test_data = list(ds1 = my_count_sf), #   prob_raster = suitability_raster, #   expected_response = expected_raster, #   metrics = c(\"rmse\", \"mae\", \"auc\", \"tss\") # )  # Example 4: Handle an inlabru-like model with an offset term # The `expected_response` raster is at the intensity scale (rate).  # cont_metrics <- compute_metrics( #   test_data = list(ds1 = my_count_sf), #   prob_raster = suitability_raster, #   expected_response = expected_raster, #   metrics = c(\"rmse\", \"auc\", \"tss\"), #   is_pred_rate = TRUE, #   exposure = \"exposure_col\" # Exposure column (e.g. sampling unit area) # )  # Example 5: Compute dataset-specific and weighted composite metrics for a joint model # expected_raster  <- suitability_index(pred_eta, #                     response_type = \"count.pa\", #                     output_format = \"response\") # suitability_raster <- suitability_index(pred_eta, #                       response_type = \"count.pa\", #                       has_offset = FALSE) # full_metrics <- compute_metrics( #   test_data = list(ds1 = my_count_sf, ds2 = my_pa_sf), #   prob_raster = suitability_raster, #   expected_response = expected_raster, #   metrics = c(\"rmse\", \"mae\", \"auc\", \"tss\", \"accuracy\") # ) } # }"},{"path":"https://sodeidelphonse.github.io/isdmtools/reference/create_folds.html","id":null,"dir":"Reference","previous_headings":"","what":"Create block cross-validation folds for multisource spatial datasets ‚Äî create_folds","title":"Create block cross-validation folds for multisource spatial datasets ‚Äî create_folds","text":"constructor function DataFolds S3 class. binds multiple sf datasets single object generates spatially environmentally-separated cross-validation folds.","code":""},{"path":"https://sodeidelphonse.github.io/isdmtools/reference/create_folds.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create block cross-validation folds for multisource spatial datasets ‚Äî create_folds","text":"","code":"create_folds(   datasets,   region_polygon = NULL,   k = 5,   seed = 23,   cv_method = \"cluster\",   ... )  bind_datasets(datasets)"},{"path":"https://sodeidelphonse.github.io/isdmtools/reference/create_folds.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create block cross-validation folds for multisource spatial datasets ‚Äî create_folds","text":"datasets named list sf objects. list element spatial dataset name corresponding list element's name. list elements must geographical projection coordinates reference system (CRS). region_polygon sf object representing study area polygon. k integer. specifies number folds (k-fold cross-validation). seed integer. sets seed reproducibility. cv_method character. specifies spatial cross-validation method use. Options \"cluster\" (default) \"spatial\", see cv_cluster cv_spatial functions. \"block\", \"buffer\", \"location\", \"nndm\", see corresponding functions spatialsample package. ... Additional arguments passed underlying blocking function blockCV spatialsample.","code":""},{"path":"https://sodeidelphonse.github.io/isdmtools/reference/create_folds.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create block cross-validation folds for multisource spatial datasets ‚Äî create_folds","text":"S3 object class DataFolds containing combined data, fold information, region polygon, original datasets. sf object containing datasets along corresponding name.","code":""},{"path":"https://sodeidelphonse.github.io/isdmtools/reference/create_folds.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Create block cross-validation folds for multisource spatial datasets ‚Äî create_folds","text":"function first binds datasets single sf object. applies chosen blocking method create spatial folds. fold IDs added combined data object, original datasets relevant information stored returned DataFolds object. \"cluster\" method blockCV package, supports spatial environmental clustering. Methods \"block\", \"buffer\", \"nndm\", \"location\"useful distance-based exclusion (buffering) leaving specific groups/locations (e.g., using group = \"column_name\" spatial_leave_location_out_cv method). Use \"spatial\" blockCV grid-blocking, \"block\" spatialsample grid-blocking. behavior create_folds depends cv_method chosen. Several methods require specific arguments passed via ellipsis (...): block & buffer: Accept radius buffer arguments define size test/assessment areas width exclusion zones, respectively. Particularly, grid-blocking \"block\" scheme, additional arguments st_make_grid can provided. nndm: Requires prediction_sites, sf object representing area model projected. location: Requires group argument (character). name column datasets representing independent units like \"site_id\", \"year\", \"observer\". tests model generalizability across factors. also accepts radius buffer arguments size assessment areas width exclusion zones, respectively.","code":""},{"path":"https://sodeidelphonse.github.io/isdmtools/reference/create_folds.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Create block cross-validation folds for multisource spatial datasets ‚Äî create_folds","text":"Mahoney MJ, Johnson LK, Silge J, Frick H, Kuhn M, Beier CM. Assessing performance spatial cross-validation approaches models spatially structured data. arXiv (2023) doi:10.48550/arXiv.2303.07334 Roberts DR, Bahn V, Ciuti S, Boyce MS, Elith J, Guillera-Arroita G, Hauenstein S, Lahoz-Monfort JJ, Schr√∂der B, Thuiller W, et al. Cross-validation strategies data temporal, spatial, hierarchical, phylogenetic structure. Ecography (2017) 40:913‚Äì929. doi:10.1111/ecog.02881 Valavi R, Elith J, Lahoz-Monfort JJ, Guillera-Arroita G. blockCV: R package generating spatially environmentally separated folds k-fold cross-validation species distribution models. bioRxiv (2018). doi:10.1101/357798","code":""},{"path":[]},{"path":"https://sodeidelphonse.github.io/isdmtools/reference/create_folds.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create block cross-validation folds for multisource spatial datasets ‚Äî create_folds","text":"","code":"if (FALSE) { # \\dontrun{ # Create some dummy sf data with different columns library(sf) set.seed(42) presence_data <- data.frame(   x = runif(100, 0, 4),   y = runif(100, 6, 13),   site = rbinom(100, 1, 0.6) ) %>% st_as_sf(coords = c(\"x\", \"y\"), crs = 4326)  count_data <- data.frame(   x = runif(50, 0, 4),   y = runif(50, 6, 13),   count = rpois(50, 5) ) %>% st_as_sf(coords = c(\"x\", \"y\"), crs = 4326)  # Create a list of datasets datasets_list <- list(Presence = presence_data, Count = count_data)  # Create a dummy polygon for the region (e.g. Benin's minimum bounding rectangle) ben_coords <- matrix(c(0, 6, 4, 6, 4, 13, 0, 13, 0, 6), ncol = 2, byrow = TRUE) ben_sf <- st_sfc(st_polygon(list(ben_coords)), crs = 4326) ben_sf <- st_sf(data.frame(name = \"Benin\"), ben_sf)  # Create a DataFolds object using the default 'cluster' method my_folds <- create_folds(datasets_list, ben_sf, k = 5) print(my_folds) } # }"},{"path":"https://sodeidelphonse.github.io/isdmtools/reference/fill_na_near.html","id":null,"dir":"Reference","previous_headings":"","what":"Fill NA cells with the nearest cells values ‚Äî fill_na_near","title":"Fill NA cells with the nearest cells values ‚Äî fill_na_near","text":"Function impute raster object spatial modeling tools handle missing values covariates. function fill NA cells nearest cells values using moving window missing cells. iterative version focal function terra handle incomplete filling due isolated NA cells surrounded NAs.","code":""},{"path":"https://sodeidelphonse.github.io/isdmtools/reference/fill_na_near.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fill NA cells with the nearest cells values ‚Äî fill_na_near","text":"","code":"fill_na_near(   x,   boundary = NULL,   fun = mean,   na.policy = \"only\",   na.rm = TRUE,   start.window = 1,   ... )"},{"path":"https://sodeidelphonse.github.io/isdmtools/reference/fill_na_near.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fill NA cells with the nearest cells values ‚Äî fill_na_near","text":"x raster layer (SpatRaster RasterLayer) missing values fill . multiple rasters (SpatRaster RasterStack), can use combination lapply() rast() functions function. boundary optional spatial polygon object (spatVector sf) used mask extra cells outside study region. must coordinates reference system (CRS) input raster. Defaults NULL. fun function compute value cell based values neighbors. default mean. function must take vector values return single value (e.g., mean, modal, min max) multiple values (e.g., quantile). na.policy Character. Specifies cells fill. Must one \"\" (compute cells), \"\" (cells NA) \"omit\" (skip cells NA). default \"\" ensures cells NA input raster filled. na.rm Logical. TRUE, NA values neighborhood ignored computing focal function. default TRUE. start.window positive odd integer specifying starting size square focal window. window (2w+1) x (2w+1). default 1, corresponds 3x3 start window. ... Additional arguments passed internal focal function. includes arguments like expand, silent, filename, etc. Note custom w (e.g., weights matrix) passed via ... function's logic built around iterative square window.","code":""},{"path":"https://sodeidelphonse.github.io/isdmtools/reference/fill_na_near.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Fill NA cells with the nearest cells values ‚Äî fill_na_near","text":"SpatRaster object NA cells filled .","code":""},{"path":"https://sodeidelphonse.github.io/isdmtools/reference/fill_na_near.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Fill NA cells with the nearest cells values ‚Äî fill_na_near","text":"","code":"if (FALSE) { # \\dontrun{ library(terra) # Create a sample raster with some NA values r <- terra::rast(nrows = 10, ncols = 10, res = 1, xmin = 0, ymin = 0) r[] <- 1:100 r[c(10, 25, 50, 75, 90)] <- NA  # Fill the NAs using the default mean function with 3x3 window r_filled <- fill_na_near(r)  # Start the filling with a larger 5x5 window r_filled_large_start <- fill_na_near(r, start.window = 3)  plot(r, main = \"Original raster\") plot(r_filled, main = \"Filled with mean (3x3 start)\") plot(r_filled_large_start, main = \"Filled with mean (5x5 start)\") } # }"},{"path":"https://sodeidelphonse.github.io/isdmtools/reference/generate_maps.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate Multi-panel Maps from Spatial Model Predictions ‚Äî generate_maps","title":"Generate Multi-panel Maps from Spatial Model Predictions ‚Äî generate_maps","text":"function creates multi-panel map visualizing multiple prediction variables species distribution model spatial model. designed flexible, handling grid-based (data.frame) point-based (sf) spatial predictions.","code":""},{"path":"https://sodeidelphonse.github.io/isdmtools/reference/generate_maps.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate Multi-panel Maps from Spatial Model Predictions ‚Äî generate_maps","text":"","code":"generate_maps(   data,   var_names = c(\"mean\", \"sd\"),   base_map = NULL,   color_gradient = map.pal(\"viridis\", 100),   legend_title = NULL,   panel_labels = NULL,   nrow = NULL,   xaxis_breaks = NULL,   yaxis_breaks = NULL,   annotate = TRUE )"},{"path":"https://sodeidelphonse.github.io/isdmtools/reference/generate_maps.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate Multi-panel Maps from Spatial Model Predictions ‚Äî generate_maps","text":"data data frame, sf SpatRaster object containing prediction data. grid-based data frame, must contain columns named \"x\" \"y\" representing pixels' coordinates. var_names character. vector column names data plotted separate panels. base_map sf object plotted base layer underneath prediction data (e.g., background simple polygon). Defaults NULL. Users can add additional vector geometries needed using ggplot2 syntax. color_gradient vector valid colors used fill/color gradient. Defaults map.pal(\"viridis\", 100). legend_title character. title color legend. panel_labels character. optional vector labels facet panels. order correspond var_names. nrow integer. number rows ggplot2::facet_wrap(). Defaults optimal layout chosen ggplot2. xaxis_breaks numeric vector specifying breaks x-axis. yaxis_breaks numeric vector specifying breaks y-axis. annotate logical. TRUE, add north arrow scale bar map. Defaults TRUE","code":""},{"path":"https://sodeidelphonse.github.io/isdmtools/reference/generate_maps.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate Multi-panel Maps from Spatial Model Predictions ‚Äî generate_maps","text":"ggplot object representing multi-panel plot can customized user.","code":""},{"path":"https://sodeidelphonse.github.io/isdmtools/reference/generate_maps.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Generate Multi-panel Maps from Spatial Model Predictions ‚Äî generate_maps","text":"function internally reshapes data wide format (column prediction variable) long format suitable plotting ggplot2::facet_wrap(). automatically selects appropriate geometry (geom_tile() grids geom_sf() points) conditional scales. Users can also add map spatial vector layers customize plot using ggplot2 syntax needed.","code":""},{"path":[]},{"path":"https://sodeidelphonse.github.io/isdmtools/reference/generate_maps.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate Multi-panel Maps from Spatial Model Predictions ‚Äî generate_maps","text":"","code":"if (FALSE) { # \\dontrun{ # --- Example with grid-based data --- # Simulate a data frame with coordinates and two prediction variables grid_data <- expand.grid(x = 1:100, y = 1:100) grid_data$mean <- rnorm(10000, mean = grid_data$x / 100, sd = 0.1) grid_data$sd <- rgamma(10000, shape = 2, scale = 0.2)  # Simulate a boundary map (e.g., a simple polygon) library(sf) boundary <- st_sfc(st_polygon(list(cbind(c(0, 100, 100, 0, 0), c(0, 0, 100, 100, 0))))) boundary_sf <- st_sf(data.frame(id = 1), geometry = boundary)  # Generate the map generate_maps(   data = grid_data,   var_names = c(\"mean\", \"sd\"),   base_map = boundary_sf,   color_gradient = c(\"white\", \"skyblue\", \"navy\"),   legend_title = \"Prediction Value\",   panel_labels = c(\"Mean\", \"StDev\"),   nrow = 1 )  # --- Example with point-based data (sf) --- # Simulate an sf object with point data library(sf) set.seed(123) points_sf <- st_as_sf(grid_data[sample(1:10000, 1000), ],                      coords = c(\"x\", \"y\"), crs = 32631) # UTM CRS points_sf <- prepare_predictions(points_sf)  # Generate the map generate_maps(   data = points_sf,   var_names = c(\"mean\", \"sd\"),   base_map = boundary_sf,   color_gradient = c(\"white\", \"orange\", \"red\"),   legend_title = \"Prediction Value\",   panel_labels = c(\"Mean\", \"StDev\"),   nrow = 1 ) } # }"},{"path":"https://sodeidelphonse.github.io/isdmtools/reference/isdmtools-package.html","id":null,"dir":"Reference","previous_headings":"","what":"A Toolkit for Integrated Species Distribution Models ‚Äî isdmtools-package","title":"A Toolkit for Integrated Species Distribution Models ‚Äî isdmtools-package","text":"isdmtools provides set tools preparing, analyzing visualizing spatial data integrated species distribution models (ISDMs). designed help users prepare multisource spatial point datasets block cross-validation, focus Bayesian inference. analyses habitat suitability joint model predictions maps results. package also provides holistic view model performance computing comprehensive evaluation metrics joint model, including ROC-based continuous-outcome weighted composite scores.","code":""},{"path":[]},{"path":"https://sodeidelphonse.github.io/isdmtools/reference/isdmtools-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"A Toolkit for Integrated Species Distribution Models ‚Äî isdmtools-package","text":"Maintainer: Akoeugnigan Idelphonse SODE sdidelphonse@gmail.com contributors: Adand√© Belarmain Fandohan [contributor] Elias Teixeira Krainski [contributor] Romain Gl√®l√® Kaka√Ø [contributor]","code":""},{"path":"https://sodeidelphonse.github.io/isdmtools/reference/prepare_predictions.html","id":null,"dir":"Reference","previous_headings":"","what":"Obtain a formatted output from spatial predictions. ‚Äî prepare_predictions","title":"Obtain a formatted output from spatial predictions. ‚Äî prepare_predictions","text":"Function transform prediction data various spatial models (e.g., inlabru, PointedSDMs GLMs tools) sf object points predictions (e.g., fm_vertices) data.frame corresponding locations pixel grids (see fm_pixels). Spatial prediction data can also obtained across given region using expand.grid(x, y) function, 'x' 'y' geographical coordinates grids locations.","code":""},{"path":"https://sodeidelphonse.github.io/isdmtools/reference/prepare_predictions.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Obtain a formatted output from spatial predictions. ‚Äî prepare_predictions","text":"","code":"prepare_predictions(prediction_data, base_map = NULL)"},{"path":"https://sodeidelphonse.github.io/isdmtools/reference/prepare_predictions.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Obtain a formatted output from spatial predictions. ‚Äî prepare_predictions","text":"prediction_data model prediction may either sf data.frame object raw prediction inlabru-like models. prediction can response linear predictor scale, depending whether output model evaluation visualization. base_map sf polygon crs spatial locations used predictions.","code":""},{"path":"https://sodeidelphonse.github.io/isdmtools/reference/prepare_predictions.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Obtain a formatted output from spatial predictions. ‚Äî prepare_predictions","text":"data.frame grid-based predictions sf object point-based predictions.","code":""},{"path":[]},{"path":"https://sodeidelphonse.github.io/isdmtools/reference/prepare_predictions.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Obtain a formatted output from spatial predictions. ‚Äî prepare_predictions","text":"","code":"if (FALSE) { # \\dontrun{ library(dplyr) library(sf) set.seed(42)  # Simulate the prediction data grid_df <- expand.grid(x = 0:50, y = 0:50) grid_df <- grid_df %>%   mutate(mu = (x + y) / 10 + rnorm(nrow(grid_df))) %>%   mutate(sd = runif(nrow(grid_df), 0.5, 1.5)) head(grid_df)  # Convert the grid into a SpatRaster grid_r <- terra::rast(grid_df, crs = \"epsg:4326\")  # a) A standard data.frame returns the same object field_pp1 <- prepare_predictions(grid_df) class(field_pp1)  # b) A grid-based object returns a data.frame grid_sf <- st_as_sf(grid_df, coords = c(\"x\", \"y\"), crs = \"epsg:4326\") class(grid_sf) <- c(\"bru_prediction\", \"sf\", \"data.frame\")  field_pp2 <- prepare_predictions(grid_sf) print(class(field_pp2))  # c) A point-based prediction returns the original class if(require(\"fmesher\", quietly = TRUE)) {   bnd  <- fm_nonconvex_hull(as.matrix(grid_df[, c(\"x\", \"y\")]), convex = -0.10)   mesh <- fm_mesh_2d(boundary = bnd, max.edge = c(3, 30), crs = \"epsg:4326\")   vt <- fm_vertices(mesh, format = \"sf\")  # An inlabru-like prediction at mesh vertices (extended areas are imputed)  sampled_vals <- terra::extract(grid_r, vt)  sim_field <- vt %>%    mutate(mean = dplyr::coalesce(sampled_vals$mu, mean(grid_df$mu, na.rm = TRUE)),          sd    = dplyr::coalesce(sampled_vals$sd, mean(grid_df$sd, na.rm = TRUE)),          q0.025 = mean - 1.96 * sd,          q0.5   = mean,          q0.975 = mean + 1.96 * sd,          median = mean)  class(sim_field) <- c(\"bru_prediction\", \"sf\", \"data.frame\")   field_pp3  <- prepare_predictions(sim_field)  print(class(field_pp3))  } } # }"},{"path":"https://sodeidelphonse.github.io/isdmtools/reference/sample_background.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate background points ‚Äî sample_background","title":"Generate background points ‚Äî sample_background","text":"constructor function generate background points various purposes (e.g. computing evaluation scores presence-data). exclude NA cells sample, eventually observed locations needed.","code":""},{"path":"https://sodeidelphonse.github.io/isdmtools/reference/sample_background.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate background points ‚Äî sample_background","text":"","code":"sample_background(   mask,   points = NULL,   n = 1000,   method = \"random\",   cells = FALSE,   xy = TRUE,   as.points = FALSE,   na.rm = TRUE,   ... )"},{"path":"https://sodeidelphonse.github.io/isdmtools/reference/sample_background.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate background points ‚Äî sample_background","text":"mask SpatRaster object used mask (preferably, predicted intensity habitat suitability). points Spatial points (data.frame, sf SpatVector objects) excluded background sample. n integer. number pseudo-absence points sample presence-data. default 1000. method character. sampling technique select pixels raster mask (see spatSample). defaults random. cells logical.  TRUE, sampled cells numbers returned. default FALSE. xy logical. TRUE, locations sampled cells returned. default TRUE. .points logical. TRUE, spatial points object returned. default FALSE. na.rm logical. TRUE, NA values excluded raster mask. defaults TRUE. ... Additional arguments passed internal spatSample function.","code":""},{"path":"https://sodeidelphonse.github.io/isdmtools/reference/sample_background.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate background points ‚Äî sample_background","text":"S3 object class BackgroundPoints, containing modified SpatRaster object generated background points.","code":""},{"path":[]},{"path":"https://sodeidelphonse.github.io/isdmtools/reference/sample_background.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate background points ‚Äî sample_background","text":"","code":"if (FALSE) { # \\dontrun{ library(terra) set.seed(123) r  <- rast(nrows = 100, ncols = 100, xmin = 0, xmax = 10, ymin = 0, ymax = 10) terra::values(r) <- runif(ncell(r)) pts <- spatSample(r, size = 100, xy = TRUE, values = FALSE)  # Requesting few points with their x and y coordinates set.seed(235) bg_sample1 <- sample_background(r, points = pts, n = 500, xy = TRUE, cells = FALSE) plot(bg_sample1) print(bg_sample1)  # Requesting points more than available non-NA cells bg_sample2 <- sample_background(r, points = pts, n = 10000, xy =TRUE, cells = FALSE) dim(bg_sample2$bg) plot(bg_sample2) } # }"},{"path":"https://sodeidelphonse.github.io/isdmtools/reference/suitability_index.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute a unified suitability index from integrated spatial model predictions. ‚Äî suitability_index","title":"Compute a unified suitability index from integrated spatial model predictions. ‚Äî suitability_index","text":"function converts linear predictor (eta) fitted integrated spatial model unified suitability index, can interpreted probability species presence. also calculates intensity(rate) expected count count data, depending whether model offset .","code":""},{"path":"https://sodeidelphonse.github.io/isdmtools/reference/suitability_index.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute a unified suitability index from integrated spatial model predictions. ‚Äî suitability_index","text":"","code":"suitability_index(   x,   post_stat = \"mean\",   output_format = c(\"prob\", \"response\", \"linear\"),   response_type = c(\"joint.po\", \"count.pa\", \"po\", \"count\", \"pa\"),   has_offset = FALSE,   scale_independent = FALSE,   projection = NULL,   ... )"},{"path":"https://sodeidelphonse.github.io/isdmtools/reference/suitability_index.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute a unified suitability index from integrated spatial model predictions. ‚Äî suitability_index","text":"x data.frame containing x y coordinates column(s) predicted linear predictor variables (e.g., mean, standard deviation quantiles) SpatRaster. can typically standardized grid-based output prepare_predictions call various classes spatial prediction linear scale, e.g. PointedSDMs inlabru packages. post_stat character. vector specifying column layer name(s) use extracting model predictions. Defaults \"mean\". output_format character. desired output format must one \"prob\" (probability-based suitability index), \"response\" (expected count rate) \"linear\" (linear predictor scale). response_type character. type response data model fitted . Must one \"joint.po\" (joint model including presence-data), \"count.pa\" (joint model count presence-absence), \"po\" (single presence-model), \"count\" (count model), \"pa\" (presence-absence model). has_offset logical. count.pa, count pa models, TRUE linear predictor includes explicit area offset. argument used \"po\" \"joint.po\" models. Defaults FALSE. scale_independent logical. TRUE, scaling factor set 1, making suitability index independent grid cell size. Defaults FALSE. projection character. coordinate reference system (CRS) output raster. Defaults NULL. NULL x data.frame, empty CRS assigned prevent errors. ... Additional arguments passed rast.","code":""},{"path":"https://sodeidelphonse.github.io/isdmtools/reference/suitability_index.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute a unified suitability index from integrated spatial model predictions. ‚Äî suitability_index","text":"SpatRaster object representing requested output format.","code":""},{"path":"https://sodeidelphonse.github.io/isdmtools/reference/suitability_index.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Compute a unified suitability index from integrated spatial model predictions. ‚Äî suitability_index","text":"function implements unified framework converting model predictions comparable suitability index. method relies Inhomogeneous Poisson Process (IPP) theory, linear predictor eta related probability presence via inverse complementary log-log link follows: \\(p(presence) = 1 - exp(-scaling \\times exp(eta))\\). scaling factor determined response_type has_offset arguments: PO models (single part joint model), eta always log-rate, scaling set cell area. ignored scale_independent set TRUE. Count PA models, has_offset = TRUE, eta log-rate, scaling cell area. cases (has_offset = FALSE), eta treated log expected count (count) cloglog probability (PA), scaling set 1. raster geographic coordinate system (longlat), area calculated \\(km^2\\) using cellSize. projected systems, area product resolutions (e.g., \\(km^2\\) units km).","code":""},{"path":"https://sodeidelphonse.github.io/isdmtools/reference/suitability_index.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Compute a unified suitability index from integrated spatial model predictions. ‚Äî suitability_index","text":"Dorazio RM. Accounting imperfect detection survey bias statistical analysis presence-data. Global Ecology Biogeography (2014) 23:1472‚Äì1484. doi:10.1111/geb.12216 Fithian W, Elith J, Hastie T, Keith DA. Bias correction species distribution models: pooling survey collection data multiple species. Methods Ecology Evolution (2015) 6:424‚Äì438. doi:10.1111/2041-210X.12242 Phillips SJ, Anderson RP, Dud√≠k M, et al Opening black box: open‚Äêsource release Maxent. Ecography (2017) 40:887‚Äì893. doi:10.1111/ecog.03049","code":""},{"path":[]},{"path":"https://sodeidelphonse.github.io/isdmtools/reference/suitability_index.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute a unified suitability index from integrated spatial model predictions. ‚Äî suitability_index","text":"","code":"if (FALSE) { # \\dontrun{ library(terra) # Simulate a sample data.frame with x, y, and a linear predictor set.seed(42) x <- expand.grid(x = seq(0, 50, 1), y = seq(0, 50, 1)) x$eta <- rnorm(nrow(x), mean = 0, sd = 1)  # Create a simple raster object x_rast <- rast(x)  # Generate a suitability index for a Presence-Absence model pa_probability <- suitability_index(   x_rast,   post_stat = \"eta\",   response_type = \"pa\" ) plot(pa_probability)  # Create a binary map using a fixed threshold binary_map <- app(pa_probability, function(x) ifelse(x < 0.5, 0, 1)) plot(binary_map)  # Generate an expected mean (assume \"eta\" is from a count model) expected_mean <- suitability_index(   x_rast,   post_stat = \"eta\",   response_type = \"count\",   output_format = \"response\" ) plot(expected_mean) } # }"},{"path":"https://sodeidelphonse.github.io/isdmtools/reference/summarise_fold_diagnostics.html","id":null,"dir":"Reference","previous_headings":"","what":"Summarise Fold Diagnostics ‚Äî summarise_fold_diagnostics","title":"Summarise Fold Diagnostics ‚Äî summarise_fold_diagnostics","text":"Combines geographic environmental diagnostics single unified report evaluate quality cross-validation scheme.","code":""},{"path":"https://sodeidelphonse.github.io/isdmtools/reference/summarise_fold_diagnostics.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Summarise Fold Diagnostics ‚Äî summarise_fold_diagnostics","text":"","code":"summarise_fold_diagnostics(geo_diag, env_diag)  # S3 method for class 'FoldsSummary' print(x, ...)"},{"path":"https://sodeidelphonse.github.io/isdmtools/reference/summarise_fold_diagnostics.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Summarise Fold Diagnostics ‚Äî summarise_fold_diagnostics","text":"geo_diag GeoDiagnostic object. env_diag EnvDiagnostic object. x FoldsSummary object. ... Additional arguments","code":""},{"path":"https://sodeidelphonse.github.io/isdmtools/reference/summarise_fold_diagnostics.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Summarise Fold Diagnostics ‚Äî summarise_fold_diagnostics","text":"summarise_fold_diagnostics: object class FoldsSummary, inherits data.frame. print: FoldsSummary object invisibly.","code":""},{"path":[]},{"path":"https://sodeidelphonse.github.io/isdmtools/reference/summarise_fold_diagnostics.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Summarise Fold Diagnostics ‚Äî summarise_fold_diagnostics","text":"","code":"if (FALSE) { # \\dontrun{ library(sf) library(terra) library(ggplot2) library(isdmtools)  # Generate points data set.seed(42) presence_data <- data.frame(   x = runif(100, 0, 4),   y = runif(100, 6, 13),   site = rbinom(100, 1, 0.6) ) %>% st_as_sf(coords = c(\"x\", \"y\"), crs = 4326)  count_data <- data.frame(   x = runif(50, 0, 4),   y = runif(50, 6, 13),  count = rpois(50, 5) ) %>% st_as_sf(coords = c(\"x\", \"y\"), crs = 4326)  datasets_list <- list(Presence = presence_data, Count = count_data)  # Environmental data set.seed(42) r <- rast(extent = c(0, 4, 6, 13), nrow=100, ncol=100, crs='epsg:4326') r[] <- rnorm(ncell(r)) rtmp   <- r rtmp[] <- runif(ncell(r), 5, 10)  r_stk <- c(r, rtmp + r) names(r_stk) <- c(\"cov1\", \"cov2\")  # Create Folds folds <- create_folds(datasets_list, cv_method = \"cluster\")  # Spatial diagnostics spat_diag <- check_folds(folds, plot = TRUE)  # Environmental diagnostics env_diag <- suppressWarnings(check_env_balance(   folds,   covariates = r_stk,   n_background = 5000) )  # Combined diagnostics sum_diag <- summarise_fold_diagnostics(spat_diag, env_diag) print(sum_diag) } # }"},{"path":[]},{"path":"https://sodeidelphonse.github.io/isdmtools/news/index.html","id":"continuous-integration--quality-assurance-0-3-0","dir":"Changelog","previous_headings":"","what":"Continuous Integration & Quality Assurance","title":"isdmtools 0.3.0","text":"GitHub Actions Integration: Established suite automated workflows including R-CMD-check cross-platform stability Codecov monitoring unit test coverage. Automated Documentation: Implemented automated pkgdown deployment pipeline ensure package website vignettes updated upon every push main branch.","code":""},{"path":"https://sodeidelphonse.github.io/isdmtools/news/index.html","id":"major-changes-0-3-0","dir":"Changelog","previous_headings":"","what":"Major Changes","title":"isdmtools 0.3.0","text":"New S3 Class Architecture: Introduced GeoDiagnostic, EnvDiagnostic, FoldsSummary classes structure spatial folds‚Äô diagnostics results. Diagnostic Framework: Refined check_folds() check_env_balance() constructors evaluate spatial independence environmental balance spatial folds. Documentation Refactor: Implemented grouped reference system consolidate S3 methods, significantly improving package Reference index.","code":""},{"path":"https://sodeidelphonse.github.io/isdmtools/news/index.html","id":"improvements-0-3-0","dir":"Changelog","previous_headings":"","what":"Improvements","title":"isdmtools 0.3.0","text":"Website Launch: Official pkgdown site deployment custom navigation bar categorised tutorials. Tutorials: Added ‚ÄúGet Started‚Äù guide advanced ‚ÄúISDM Evaluation Workflow‚Äù vignette conditional evaluation external dependencies.","code":""},{"path":[]},{"path":"https://sodeidelphonse.github.io/isdmtools/news/index.html","id":"new-features-0-2-0","dir":"Changelog","previous_headings":"","what":"New Features","title":"isdmtools 0.2.0","text":"Add folds diagnostics tools: check_folds check_env_balance key methods operating DataFolds objects check independence representativeness generated folds. New CV Methods: Added support four new cv_method options advanced spatial cross-validation: ‚Äúblock‚Äù: Grid-based blocking via ‚Äúspatialsample‚Äù (similar ‚Äúspatial‚Äù blockCV exclusion buffer). ‚Äúnndm‚Äù: Nearest Neighbor Distance Matching matching prediction validation environments. ‚Äúbuffer‚Äù: Distance-based exclusion zones (Leave-One-buffer). ‚Äúlocation‚Äù: Leave-location-/Leave-group-CV, enabling spatiotemporal validation (e.g., year) source-specific validation (e.g., observers, sites regions). Expanded Cross-Validation Engines: Integrated ‚Äòspatialsample‚Äô backend, providing unified interface advanced spatial resampling methods. Buffer-Aware Extraction: Updated extract_fold() automatically handle exclusion zones. Points falling within spatial buffers now correctly identified NA excluded training testing sets prevent spatial autocorrelation bias. Added summary.DataFolds method providing clean aggregated statistics data partition. Added relevant tests DataFolds BackgroundPoints classes constructors/methods.","code":""},{"path":"https://sodeidelphonse.github.io/isdmtools/news/index.html","id":"enhanced-features-0-2-0","dir":"Changelog","previous_headings":"","what":"Enhanced Features","title":"isdmtools 0.2.0","text":"Refactoring: Remove unnecessary dependencies (reshape2, purrr ggspatial) ensure consistent argument naming (snake_case). Unified CV Constructor: create_folds() now acts high-level bridge blockCV spatialsample. Standardized S3 Outputs: DataFolds object now standardizes internal indexing across different blocking engines, ensuring ‚Äúfolds_ids‚Äù consistent regardless underlying package used. Improved Print Method: print.DataFolds method now explicitly labels ‚ÄúExcluded‚Äù points, providing clear summary many observations buffered validation process. Added robust unit tests spatial buffer logic multisource data fusion integrity.","code":""},{"path":[]},{"path":"https://sodeidelphonse.github.io/isdmtools/news/index.html","id":"refactoring--internal-checks-0-1-0-9000","dir":"Changelog","previous_headings":"","what":"Refactoring & internal checks","title":"isdmtools 0.1.0.9000","text":"Integrated unit testing framework using testthat. Standardized coordinate column names lowercase x y across functions. Updated internal logic use .data pronouns resolve global variable notes.","code":""},{"path":"https://sodeidelphonse.github.io/isdmtools/news/index.html","id":"enhanced-features-0-1-0-9000","dir":"Changelog","previous_headings":"","what":"Enhanced Features","title":"isdmtools 0.1.0.9000","text":"Implemented S3 methods ISDMmetrics: print(), summary(), plot(), .data.frame(), [. Added ISDMmetrics S3 class handle outputs compute_metrics(). Implemented get_background helper function selected background points. Enhanced suitability_index(): Added \"linear\" output.format options. Updated DESCRIPTION new minimum version requirements package dependencies (sf, terra, purrr) ensure compatibility recent environment updates.","code":""},{"path":"https://sodeidelphonse.github.io/isdmtools/news/index.html","id":"isdmtools-010","dir":"Changelog","previous_headings":"","what":"isdmtools 0.1.0","title":"isdmtools 0.1.0","text":"Initial release supporting ‚ÄúIntegrating Presence-Abundance Data Predict Baobab (Adansonia digitata L.) Distribution: Bayesian Data Fusion Framework‚Äù. DOI: 10.21203/rs.3.rs-7871875/v1","code":""}]
